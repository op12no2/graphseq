<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>MIDI Graph Sequencer</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      background: #1a1a1a;
      font-family: monospace;
      color: #aaa;
      overflow: hidden;
    }
    
    #properties-sidebar {
      position: fixed;
      top: 64px;
      left: 0;
      bottom: 0;
      width: 240px;
      background: #242424;
      border-right: 1px solid #333;
      overflow-y: auto;
      padding: 16px;
      box-sizing: border-box;
      z-index: 50;
    }
    
    #properties-sidebar h3 {
      margin: 0 0 12px 0;
      font-size: 11px;
      text-transform: uppercase;
      color: #666;
      letter-spacing: 0.5px;
    }
    
    .property-section {
      margin-bottom: 20px;
    }
    
    .property-label {
      font-size: 11px;
      color: #888;
      margin-bottom: 6px;
      text-transform: uppercase;
      letter-spacing: 0.3px;
    }
    
    .note-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 4px;
      margin-bottom: 8px;
    }
    
    .note-btn {
      padding: 8px 4px;
      background: #2a2a2a;
      border: 1px solid #3a3a3a;
      border-radius: 3px;
      color: #aaa;
      cursor: pointer;
      font-size: 11px;
      text-align: center;
      transition: all 0.1s;
    }
    
    .note-btn:hover {
      background: #333;
      border-color: #4a4a4a;
    }
    
    .note-btn.selected {
      background: #4a4a4a;
      border-color: #5a5a5a;
      color: #fff;
    }
    
    .octave-selector {
      display: flex;
      gap: 4px;
      margin-top: 6px;
    }
    
    .octave-btn {
      flex: 1;
      padding: 6px;
      background: #2a2a2a;
      border: 1px solid #3a3a3a;
      border-radius: 3px;
      color: #aaa;
      cursor: pointer;
      font-size: 10px;
      text-align: center;
    }
    
    .octave-btn:hover {
      background: #333;
    }
    
    .octave-btn.selected {
      background: #4a4a4a;
      border-color: #5a5a5a;
      color: #fff;
    }
    
    .color-palette-inline {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 6px;
      max-width: 120px;
      margin: 0 auto;
    }
    
    .color-swatch-inline {
      width: 100%;
      aspect-ratio: 1;
      border-radius: 3px;
      cursor: pointer;
      border: 2px solid transparent;
      transition: all 0.1s;
    }
    
    .color-swatch-inline:hover {
      transform: scale(1.15);
    }
    
    .color-swatch-inline.selected {
      border-color: #fff;
      box-shadow: 0 0 6px rgba(255,255,255,0.4);
    }
    
    .property-slider {
      width: 100%;
      margin-top: 4px;
    }
    
    .color-slider {
      width: 100%;
      margin-top: 4px;
      -webkit-appearance: none;
      appearance: none;
      height: 8px;
      border-radius: 4px;
      outline: none;
      background: linear-gradient(to right,
        #ff6b6b, #ee5a6f, #c44569, #a8336a,
        #4ecdc4, #45b7d1, #5f9ef7, #3867d6,
        #feca57, #ff9ff3, #fd79a8, #a29bfe,
        #26de81, #20bf6b, #95e1d3, #888888
      );
    }
    
    .color-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #fff;
      border: 2px solid #333;
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }
    
    .color-slider::-moz-range-thumb {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #fff;
      border: 2px solid #333;
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }
    
    .color-preview {
      width: 100%;
      height: 24px;
      margin-top: 8px;
      border-radius: 4px;
      border: 1px solid #444;
    }
    
    .property-select {
      width: 100%;
      padding: 6px 8px;
      background: #2a2a2a;
      color: #ccc;
      border: 1px solid #444;
      border-radius: 4px;
      cursor: pointer;
      font-family: inherit;
      font-size: 13px;
    }
    
    .property-select:hover {
      border-color: #666;
    }
    
    .property-select:focus {
      outline: none;
      border-color: #888;
    }
    
    .property-button {
      width: 100%;
      padding: 8px;
      margin-top: 6px;
      background: #3a3a3a;
      color: #ccc;
      border: 1px solid #555;
      border-radius: 4px;
      cursor: pointer;
      font-family: inherit;
      font-size: 12px;
      transition: all 0.15s;
    }
    
    .property-button:hover {
      background: #4a4a4a;
      border-color: #666;
    }
    
    .property-button-warning {
      background: #664400;
      border-color: #886600;
    }
    
    .property-button-warning:hover {
      background: #885500;
      border-color: #aa7700;
    }
    
    .property-button-danger {
      background: #662222;
      border-color: #883333;
    }
    
    .property-button-danger:hover {
      background: #883333;
      border-color: #aa4444;
    }
    
    .property-value {
      font-size: 11px;
      color: #ccc;
      margin-top: 4px;
    }
    
    .property-checkbox {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 8px;
      cursor: pointer;
    }
    
    .property-checkbox input {
      cursor: pointer;
    }
    
    #menu-bar {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 24px;
      background: #1a1a1a;
      border-bottom: 1px solid #333;
      display: flex;
      align-items: center;
      padding: 0 8px;
      font-size: 12px;
      font-family: monospace;
      z-index: 200;
      gap: 16px;
    }
    
    .menu-item {
      position: relative;
      color: #888;
      cursor: pointer;
      padding: 4px 8px;
      border-radius: 3px;
      user-select: none;
    }
    
    .menu-item:hover {
      background: #2a2a2a;
      color: #ccc;
    }
    
    .menu-dropdown {
      position: absolute;
      top: 100%;
      left: 0;
      margin-top: 4px;
      background: #2a2a2a;
      border: 1px solid #444;
      border-radius: 4px;
      min-width: 120px;
      display: none;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
      z-index: 300;
    }
    
    .menu-dropdown.active {
      display: block;
    }
    
    .menu-dropdown-item {
      padding: 6px 12px;
      color: #ccc;
      cursor: pointer;
      font-family: monospace;
      font-size: 12px;
    }
    
    .menu-dropdown-item:hover {
      background: #3a3a3a;
      color: #fff;
    }
    
    .menu-dropdown-item:first-child {
      border-radius: 4px 4px 0 0;
    }
    
    .menu-dropdown-item:last-child {
      border-radius: 0 0 4px 4px;
    }
    
    #container {
      position: fixed;
      top: 64px;
      left: 240px;
      right: 0;
      bottom: 0;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    
    #midi-status {
      position: fixed;
      top: 38px;
      left: 10px;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      color: #888;
      z-index: 100;
    }
    
    #transport {
      position: fixed;
      top: 28px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 4px;
      z-index: 100;
    }
    
    #bpm-display {
      position: fixed;
      top: 28px;
      left: 50%;
      transform: translateX(-150px);
      height: 32px;
      padding: 0 8px;
      background: transparent;
      border: 1px solid transparent;
      border-radius: 4px;
      color: #888;
      font-size: 12px;
      display: flex;
      align-items: center;
      gap: 4px;
      cursor: ew-resize;
      transition: all 0.2s;
      z-index: 100;
      user-select: none;
    }
    
    #beat-counter {
      position: fixed;
      top: 28px;
      left: 50%;
      transform: translateX(100px);
      height: 32px;
      padding: 0 12px;
      background: transparent;
      border: 1px solid transparent;
      border-radius: 4px;
      color: #888;
      font-size: 14px;
      font-family: monospace;
      display: flex;
      align-items: center;
      gap: 6px;
      z-index: 100;
      user-select: none;
    }
    
    #beat-value {
      color: #4ecdc4;
      min-width: 50px;
      text-align: center;
    }
    
    #graph-counter {
      position: fixed;
      top: 28px;
      left: 50%;
      transform: translateX(250px);
      height: 32px;
      padding: 0 12px;
      background: transparent;
      border: 1px solid transparent;
      border-radius: 4px;
      color: #888;
      font-size: 14px;
      font-family: monospace;
      display: flex;
      align-items: center;
      gap: 6px;
      z-index: 100;
      user-select: none;
    }
    
    #graph-value {
      color: #4ecdc4;
      min-width: 80px;
      text-align: center;
    }
    
    #bpm-display:hover {
      background: rgba(255, 255, 255, 0.05);
      border-color: #444;
      color: #aaa;
    }
    
    #bpm-value {
      font-family: monospace;
      min-width: 30px;
      text-align: right;
    }
    
    .transport-btn {
      width: 32px;
      height: 32px;
      padding: 0;
      background: transparent;
      border: none;
      border-radius: 4px;
      color: #888;
      font-size: 16px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: system-ui, -apple-system, sans-serif;
      -webkit-text-fill-color: #888; /* Force text color on Chromebook */
    }
    
    .transport-btn:hover {
      color: #ddd;
      background: rgba(255, 255, 255, 0.05);
      -webkit-text-fill-color: #ddd;
    }
    
    .transport-btn.active {
      color: #4ecdc4;
      background: rgba(78, 205, 196, 0.1);
      -webkit-text-fill-color: #4ecdc4;
    }
    
    .transport-btn:disabled {
      color: #444;
      cursor: not-allowed;
      -webkit-text-fill-color: #444;
    }
    
    .transport-btn:disabled:hover {
      background: transparent;
    }
    
    #status-text {
      transition: opacity 2s ease-out;
    }
    
    #status-text.fade-out {
      opacity: 0;
    }
    
    .status-light {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      border: 1px solid #333;
    }
    
    .status-light.connected {
      background: #4a4;
      box-shadow: 0 0 8px #4a4;
    }
    
    .status-light.disconnected {
      background: #a44;
      box-shadow: 0 0 8px #a44;
      cursor: pointer;
    }
    
    .status-light.disconnected:hover {
      background: #c55;
      box-shadow: 0 0 12px #c55;
    }
    
    canvas {
      border: 1px solid #333;
      cursor: crosshair;
    }
    
    .context-menu {
      position: absolute;
      background: #2a2a2a;
      border: 1px solid #444;
      border-radius: 4px;
      padding: 4px 0;
      min-width: 150px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.5);
      z-index: 1000;
    }
    
    .context-menu-item {
      padding: 8px 16px;
      cursor: pointer;
      color: #ccc;
      font-size: 14px;
    }
    
    .context-menu-item:hover {
      background: #3a3a3a;
      color: #fff;
    }
    
    .context-menu-item.danger:hover {
      background: #662222;
      color: #ffaaaa;
    }
    
    .context-menu-divider {
      height: 1px;
      background: #444;
      margin: 4px 0;
    }
    
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 2000;
    }
    
    .modal {
      background: #2a2a2a;
      border: 1px solid #444;
      border-radius: 8px;
      padding: 24px;
      min-width: 300px;
      box-shadow: 0 4px 16px rgba(0,0,0,0.5);
    }
    
    .modal h3 {
      margin: 0 0 16px 0;
      color: #fff;
      font-size: 18px;
    }
    
    .modal h4 {
      margin: 16px 0 8px 0;
      color: #ddd;
      font-size: 14px;
      font-weight: 700;
      border-bottom: 1px solid #444;
      padding-bottom: 4px;
    }
    
    .modal-row {
      display: flex;
      align-items: center;
      margin-bottom: 12px;
      gap: 12px;
    }
    
    .modal-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-bottom: 12px;
    }
    
    .color-palette {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 8px;
      margin: 12px 0;
    }
    
    .color-swatch {
      width: 32px;
      height: 32px;
      border-radius: 4px;
      cursor: pointer;
      border: 2px solid #333;
      transition: all 0.2s;
    }
    
    .color-swatch:hover {
      transform: scale(1.1);
      border-color: #666;
    }
    
    .color-swatch.selected {
      border-color: #fff;
      border-width: 3px;
    }
    
    .modal-row label {
      flex: 1;
      color: #ccc;
      font-size: 14px;
    }
    
    .modal-row input[type="color"] {
      width: 60px;
      height: 32px;
      border: 1px solid #444;
      background: #1a1a1a;
      cursor: pointer;
    }
    
    .modal-buttons {
      display: flex;
      gap: 8px;
      margin-top: 20px;
      justify-content: flex-end;
    }
    
    .modal-button {
      padding: 8px 16px;
      border: 1px solid #444;
      background: #3a3a3a;
      color: #ccc;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      font-family: monospace;
    }
    
    .modal-button:hover {
      background: #4a4a4a;
      color: #fff;
    }
    
    .modal-button.primary {
      background: #4a6a8a;
      border-color: #5a7a9a;
    }
    
    .modal-button.primary:hover {
      background: #5a7a9a;
    }
  </style>
</head>
<body>
  <!-- Properties Sidebar -->
  <div id="properties-sidebar">
    <div id="properties-content">
      <h3>Properties</h3>
      <div class="property-section">
        <div class="property-label">Nothing Selected</div>
      </div>
    </div>
  </div>
  
  <div id="menu-bar">
    <div class="menu-item" id="menu-file">
      File
      <div class="menu-dropdown" id="file-dropdown">
        <div class="menu-dropdown-item" id="menu-save">Save</div>
        <div class="menu-dropdown-item" id="menu-load">Open</div>
      </div>
    </div>
    <div class="menu-item" id="menu-webaudio">
      Web Audio
      <div class="menu-dropdown" id="webaudio-dropdown">
        <div class="menu-dropdown-item" data-channel="0">Channel 0</div>
        <div class="menu-dropdown-item" data-channel="1">Channel 1</div>
        <div class="menu-dropdown-item" data-channel="2">Channel 2</div>
        <div class="menu-dropdown-item" data-channel="3">Channel 3</div>
        <div class="menu-dropdown-item" data-channel="4">Channel 4</div>
        <div class="menu-dropdown-item" data-channel="5">Channel 5</div>
        <div class="menu-dropdown-item" data-channel="6">Channel 6</div>
        <div class="menu-dropdown-item" data-channel="7">Channel 7</div>
        <div class="menu-dropdown-item" data-channel="8">Channel 8</div>
        <div class="menu-dropdown-item" data-channel="9">Channel 9</div>
        <div class="menu-dropdown-item" data-channel="10">Channel 10</div>
        <div class="menu-dropdown-item" data-channel="11">Channel 11</div>
        <div class="menu-dropdown-item" data-channel="12">Channel 12</div>
        <div class="menu-dropdown-item" data-channel="13">Channel 13</div>
        <div class="menu-dropdown-item" data-channel="14">Channel 14</div>
        <div class="menu-dropdown-item" data-channel="15">Channel 15</div>
      </div>
    </div>
  </div>
  
  <div id="container">
    <div id="midi-status">
      <div class="status-light disconnected" id="status-light" title="Click to retry MIDI connection"></div>
      <span id="status-text">MIDI Disconnected</span>
    </div>
    <div id="bpm-display" title="Drag left/right to change BPM">
      <span>♩</span>
      <span id="bpm-value">120</span>
    </div>
    <div id="transport">
      <button class="transport-btn" id="play-btn" title="Play">▶</button>
      <button class="transport-btn" id="pause-btn" title="Pause" disabled>⏸</button>
      <button class="transport-btn" id="stop-btn" title="Stop" disabled>⏹</button>
    </div>
    <div id="graph-counter" title="notes : links : agents">
      <span id="graph-value">0:0:0</span>
    </div>
    <div id="beat-counter" title="bar : 1/4 note : 1/16 note">
      <span id="beat-value">1:1:1</span>
    </div>
    <canvas id="canvas"></canvas>
  </div>
  
  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    const gridSpacing = 30; // Visual grid spacing - use zoom to adjust scale
    const noteRadius = 8;
    
    // Theme definitions
    const themes = {
      dark: {
        name: 'Dark',
        backgroundColor: '#0a0a0a',
        gridColor: '#1a1a1a',
        linkColor: '#cccccc',
        teleportLinkColor: '#feca57' // Yellow for teleport links
      }
      // More themes can be added here later
    };
    
    // Curated color palette - 16 colors that look good on dark background
    const colorPalette = [
      '#ff6b6b', '#ee5a6f', '#c44569', '#a8336a', // Reds/Pinks
      '#4ecdc4', '#45b7d1', '#5f9ef7', '#3867d6', // Cyans/Blues
      '#feca57', '#ff9ff3', '#fd79a8', '#a29bfe', // Yellows/Purples
      '#26de81', '#20bf6b', '#95e1d3', '#888888'  // Greens/Gray
    ];
    
    const notes = new Map(); // key: "x,y" -> note object
    
    // Camera state
    let zoom = 1.0;
    let panX = 0;
    let panY = 0;
    
    // Pan state
    let isPanning = false;
    let lastMouseX = 0;
    let lastMouseY = 0;
    
    // Zoom state
    let zooming = false;
    let zoomStartY = 0;
    let zoomStartX = 0;
    let zoomStartValue = 1.0;
    
    // Note dragging state
    let draggedNote = null;
    let dragStartWorld = null;
    let draggedNoteOriginalPos = null;
    
    // Link creation state
    let linkingFromNote = null;
    let linkingMousePos = null;
    
    // Selection tracking for properties sidebar
    let selectedNote = null;
    let selectedLink = null;
    
    // Template copies - initialized with factory defaults, updated when properties change
    let lastNoteTemplate = {
      midiNote: 60,        // C4
      noteName: 'C4',
      channel: 0,
      duration: 0.25,      // Quarter note
      velocity: 64,        // -6dB (standard default)
      shape: 'circle',
      color: '#3867d6',    // Lovely blue (8th color in palette)
      size: 10,
      isStart: false,      // Never copy root status to new notes
      monophonic: false,   // Skip trigger if any note in same graph playing
      graph: 0,            // Graph grouping (0 = no monophonic grouping, 1+ = mono group)
      hold: 0              // Wait for 0-100% of duration before spawning agents
    };
    
    let lastLinkTemplate = {
      weight: 1,
      probability: 100,  // 0-100, chance this link fires
      group: 0,          // 0-10, links in same group compete
      phase: 0
    };
    
    // Model metadata
    let modelName = 'Untitled';
    let modelDescription = '';
    
    // MIDI state
    // Web Audio synth (fallback when MIDI unavailable)
    const audioSynth = {
      context: null,
      activeOscillators: new Map(), // Track playing notes: midiNote -> {osc, gain}
      
      init() {
        try {
          this.context = new (window.AudioContext || window.webkitAudioContext)();
          console.log('Web Audio initialized');
          return true;
        }
        catch (err) {
          console.error('Web Audio initialization failed:', err);
          return false;
        }
      },
      
      midiToFreq(midiNote) {
        // A4 (MIDI note 69) = 440 Hz
        return 440 * Math.pow(2, (midiNote - 69) / 12);
      },
      
      playNote(midiNote, velocity, duration, channel = 0) {
        if (!this.context) return;
        
        // Resume context if suspended (browser autoplay policy)
        if (this.context.state === 'suspended') {
          this.context.resume();
        }
        
        // Get channel-specific settings
        const ch = settings.synthChannels[channel];
        
        const freq = this.midiToFreq(midiNote);
        let source;
        const gain = this.context.createGain();
        
        // Create noise or oscillator based on type
        if (ch.oscillatorType === 'noise') {
          // Generate white noise buffer
          const bufferSize = this.context.sampleRate * 0.5; // 0.5 second buffer
          const buffer = this.context.createBuffer(1, bufferSize, this.context.sampleRate);
          const data = buffer.getChannelData(0);
          for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1; // White noise: -1 to 1
          }
          
          source = this.context.createBufferSource();
          source.buffer = buffer;
          source.loop = true; // Loop for sustained notes
        } else {
          // Standard oscillator
          source = this.context.createOscillator();
          source.type = ch.oscillatorType;
          source.frequency.value = freq;
        }
        
        // Configure envelope (ADSR) with channel settings
        const vol = (velocity / 127) * ch.volume;
        const now = this.context.currentTime;
        const attack = ch.attack;
        const decay = ch.decay;
        const sustain = vol * ch.sustain;
        const release = ch.release;
        
        // Attack-Decay-Sustain
        gain.gain.setValueAtTime(0, now);
        gain.gain.linearRampToValueAtTime(vol, now + attack);
        gain.gain.linearRampToValueAtTime(sustain, now + attack + decay);
        
        // Connect audio graph
        if (ch.filterEnabled) {
          // With filter: source -> filter -> gain -> destination
          const filter = this.context.createBiquadFilter();
          filter.type = 'lowpass';
          filter.frequency.value = freq * ch.filterMultiplier;
          filter.Q.value = ch.filterQ;
          source.connect(filter);
          filter.connect(gain);
        } else {
          // Direct: source -> gain -> destination
          source.connect(gain);
        }
        gain.connect(this.context.destination);
        
        // Start playing
        source.start(now);
        
        // Schedule release and stop
        const releaseTime = now + duration / 1000;
        gain.gain.setValueAtTime(sustain, releaseTime);
        gain.gain.linearRampToValueAtTime(0, releaseTime + release);
        source.stop(releaseTime + release);
        
        // Track active note
        this.activeOscillators.set(midiNote, { osc: source, gain });
        
        // Clean up when done
        source.onended = () => {
          this.activeOscillators.delete(midiNote);
        };
      },
      
      stopNote(midiNote) {
        if (!this.context) return;
        
        const active = this.activeOscillators.get(midiNote);
        if (active) {
          const now = this.context.currentTime;
          const release = 0.05; // Quick release
          
          active.gain.gain.cancelScheduledValues(now);
          active.gain.gain.setValueAtTime(active.gain.gain.value, now);
          active.gain.gain.linearRampToValueAtTime(0, now + release);
          active.osc.stop(now + release);
          
          this.activeOscillators.delete(midiNote);
        }
      },
      
      stopAll() {
        for (const [midiNote, active] of this.activeOscillators) {
          this.stopNote(midiNote);
        }
      }
    };
    
    const midi = {
      access: null,
      output: null,
      connected: false,
      useWebAudio: false, // Flag for fallback
      
      async init() {
        try {
          this.access = await navigator.requestMIDIAccess();
          
          // Find virtual MIDI port (loopMIDI on Windows, IAC Driver on Mac, or any virtual port)
          for (const output of this.access.outputs.values()) {
            const name = output.name.toLowerCase();
            // Check for common virtual MIDI ports
            if (name.includes('loopmidi') || 
                name.includes('loop midi') ||
                name.includes('iac') ||
                name.includes('bus') ||
                name.includes('virtual')) {
              this.output = output;
              this.connected = true;
              console.log('Connected to MIDI port:', output.name);
              return true;
            }
          }
          
          // If no virtual port found, try to use the first available output
          if (this.access.outputs.size > 0) {
            this.output = this.access.outputs.values().next().value;
            this.connected = true;
            console.log('Connected to MIDI port:', this.output.name);
            return true;
          }
          
          console.warn('No MIDI ports found, falling back to Web Audio');
          this.useWebAudio = true;
          return audioSynth.init();
        }
        catch (err) {
          console.error('MIDI initialization failed, falling back to Web Audio:', err);
          this.useWebAudio = true;
          return audioSynth.init();
        }
      },
      
      sendNote(note, velocity, channel = 0) {
        if (this.useWebAudio) {
          // Web Audio doesn't use channels, just ignore
          return; // Note: duration handled by activeNotes system
        }
        if (!this.output) return;
        const status = 0x90 | (channel & 0x0F);
        this.output.send([status, note & 0x7F, velocity & 0x7F]);
      },
      
      sendNoteOff(note, channel = 0) {
        if (this.useWebAudio) {
          audioSynth.stopNote(note);
          return;
        }
        if (!this.output) return;
        const status = 0x80 | (channel & 0x0F);
        this.output.send([status, note & 0x7F, 0]);
      },
      
      sendCC(cc, value, channel = 0) {
        if (this.useWebAudio) return; // Web Audio doesn't support CC
        if (!this.output) return;
        const status = 0xB0 | (channel & 0x0F);
        this.output.send([status, cc & 0x7F, value & 0x7F]);
      }
    };
    
    // Context menu state
    
    // Transport state
    let isPlaying = false;
    let isPaused = false;
    let beatCount = 0; // Tracks beats (quarter notes) since play started
    let playStartTime = 0; // When play button was pressed
    
    // Agents
    const agents = [];
    let lastFrameTime = 0;
    
    // Active MIDI notes (for proper note-off timing)
    const activeNotes = []; // { midiNote, channel, offTime }
    
    // Settings
    let settings = {
      version: "0.5",
      // Graph settings
      theme: 'dark',
      backgroundColor: themes.dark.backgroundColor,
      gridColor: themes.dark.gridColor,
      linkColor: themes.dark.linkColor,
      teleportLinkColor: themes.dark.teleportLinkColor,
      noteColor: '#3867d6', // 8th color in palette - lovely blue
      noteSize: 10,
      noteShape: 'circle',
      
      // Default note properties (for creating new notes)
      midiNote: 60, // C4
      noteDuration: 0.25, // Quarter note
      
      // Visual tuning constants
      agentSize: 10, // Agent circle radius
      arrowSize: 6, // Link arrow head size
      linkLineWidth: 1.5, // Link stroke width
      linkCreatingDashPattern: [5, 5], // Dash pattern while creating link
      noteStrokeWidth: 2, // Note outline width
      noteRootStrokeWidth: 3, // Root note outline width (thicker)
      gridLineWidth: 1, // Grid line width
      phaseIndicatorRadius: 4, // Phase position circle radius
      linkClickThreshold: 8, // Distance in pixels to click a link
      
      // Note fire visual feedback
      noteFireFlashDuration: 150, // ms to show note fire flash
      noteFireFlashBrightness: 1.3, // Size multiplier when fired (1.0 = normal)
      noteFireFlashColor: '#cccccc', // Flash color (use less bright gray instead of white)
      
      // Color picker
      colorSwatchSize: 16, // px - size of color picker swatches
      
      // Link property limits
      linkMaxGroups: 10, // Maximum group ID (0-10)
      linkMaxWeight: 100, // Maximum weight value (0-100, 0 = equal if all are 0)
      
      // Link probability visual feedback
      linkProbabilityMinBrightness: 50,  // rgb value at 0% probability (dark gray)
      linkProbabilityMaxBrightness: 204, // rgb value at 100% probability (off-white)
      
      // Selection box
      selectionBoxPaddingNote: 20, // Extra space around selected notes
      linkSelectionBoxScale: 0.3, // Link selection box size as fraction of link length
      selectionBoxDashPattern: [4, 4], // Dotted pattern for selection box
      selectionBoxColor: '#aaaaaa', // Selection box color (darker gray)
      selectionBoxLineWidth: 1, // Selection box stroke width
      selectionBoxXSize: 10, // Size of X marker at center of selection box
      bidirectionalLinkOffset: 3, // Perpendicular offset for bidirectional links
      
      // Note size limits
      noteMinSize: 4, // Minimum note size
      noteMaxSize: 20, // Maximum note size
      
      // Timing
      playStartDelay: 0, // ms delay before playback starts
      
      // Web Audio synth per-channel settings (channels 0-15)
      synthChannels: [
        // Channel 0 - Bass (sine)
        {
          oscillatorType: 'sine',
          volume: 0.2,
          attack: 0.05,
          decay: 0.1,
          sustain: 0.8,
          release: 0.1,
          filterEnabled: false,
          filterMultiplier: 2,
          filterQ: 1
        },
        // Channel 1 - Bass (square)
        {
          oscillatorType: 'square',
          volume: 0.15,
          attack: 0.01,
          decay: 0.1,
          sustain: 0.6,
          release: 0.1,
          filterEnabled: true,
          filterMultiplier: 3,
          filterQ: 1
        },
        // Channel 2 - Lead (sawtooth)
        {
          oscillatorType: 'sawtooth',
          volume: 0.15,
          attack: 0.02,
          decay: 0.1,
          sustain: 0.7,
          release: 0.1,
          filterEnabled: true,
          filterMultiplier: 4,
          filterQ: 1.5
        },
        // Channel 3 - Lead (square, punchy)
        {
          oscillatorType: 'square',
          volume: 0.12,
          attack: 0.01,
          decay: 0.05,
          sustain: 0.6,
          release: 0.05,
          filterEnabled: false,
          filterMultiplier: 4,
          filterQ: 1
        },
        // Channel 4 - Lead (triangle, smooth)
        {
          oscillatorType: 'triangle',
          volume: 0.15,
          attack: 0.02,
          decay: 0.1,
          sustain: 0.7,
          release: 0.1,
          filterEnabled: false,
          filterMultiplier: 4,
          filterQ: 1
        },
        // Channel 5 - Pad (triangle, slow)
        {
          oscillatorType: 'triangle',
          volume: 0.1,
          attack: 0.3,
          decay: 0.2,
          sustain: 0.8,
          release: 0.5,
          filterEnabled: true,
          filterMultiplier: 3,
          filterQ: 1
        },
        // Channel 6 - Pad (sine, very slow)
        {
          oscillatorType: 'sine',
          volume: 0.1,
          attack: 0.5,
          decay: 0.2,
          sustain: 0.9,
          release: 0.6,
          filterEnabled: false,
          filterMultiplier: 4,
          filterQ: 1
        },
        // Channel 7 - Pad (sawtooth, warm)
        {
          oscillatorType: 'sawtooth',
          volume: 0.08,
          attack: 0.3,
          decay: 0.2,
          sustain: 0.8,
          release: 0.4,
          filterEnabled: true,
          filterMultiplier: 2.5,
          filterQ: 1
        },
        // Channel 8 - Pluck (triangle)
        {
          oscillatorType: 'triangle',
          volume: 0.15,
          attack: 0.001,
          decay: 0.2,
          sustain: 0.2,
          release: 0.1,
          filterEnabled: true,
          filterMultiplier: 5,
          filterQ: 2
        },
        // Channel 9 - Kick (noise, low filter)
        {
          oscillatorType: 'noise',
          volume: 0.3,
          attack: 0.001,
          decay: 0.1,
          sustain: 0.1,
          release: 0.05,
          filterEnabled: true,
          filterMultiplier: 1.5,
          filterQ: 1
        },
        // Channel 10 - Snare (noise, mid filter)
        {
          oscillatorType: 'noise',
          volume: 0.2,
          attack: 0.001,
          decay: 0.05,
          sustain: 0.1,
          release: 0.05,
          filterEnabled: true,
          filterMultiplier: 3,
          filterQ: 1.5
        },
        // Channel 11 - Hi-hat (noise, high filter)
        {
          oscillatorType: 'noise',
          volume: 0.15,
          attack: 0.001,
          decay: 0.02,
          sustain: 0.05,
          release: 0.02,
          filterEnabled: true,
          filterMultiplier: 8,
          filterQ: 2
        },
        // Channel 12 - FX (noise, swept)
        {
          oscillatorType: 'noise',
          volume: 0.1,
          attack: 0.2,
          decay: 0.3,
          sustain: 0.3,
          release: 0.4,
          filterEnabled: true,
          filterMultiplier: 6,
          filterQ: 3
        },
        // Channel 13 - FX (square, weird)
        {
          oscillatorType: 'square',
          volume: 0.08,
          attack: 0.1,
          decay: 0.5,
          sustain: 0.4,
          release: 0.8,
          filterEnabled: true,
          filterMultiplier: 10,
          filterQ: 5
        },
        // Channel 14 - Ambience (sawtooth, slow)
        {
          oscillatorType: 'sawtooth',
          volume: 0.06,
          attack: 0.8,
          decay: 0.5,
          sustain: 0.9,
          release: 1.0,
          filterEnabled: true,
          filterMultiplier: 2,
          filterQ: 1
        },
        // Channel 15 - Ambience (noise, textural)
        {
          oscillatorType: 'noise',
          volume: 0.05,
          attack: 0.5,
          decay: 0.3,
          sustain: 0.7,
          release: 0.8,
          filterEnabled: true,
          filterMultiplier: 4,
          filterQ: 2
        }
      ],
      
      // System settings
      bpm: 120
    };
    
    // Apply theme colors to settings
    function applyTheme(themeName) {
      const theme = themes[themeName];
      if (theme) {
        settings.theme = themeName;
        settings.backgroundColor = theme.backgroundColor;
        settings.gridColor = theme.gridColor;
        settings.linkColor = theme.linkColor;
        settings.teleportLinkColor = theme.teleportLinkColor;
      }
    }
    
    // Draw different note shapes
    function drawNoteShape(ctx, x, y, size, shape) {
      ctx.beginPath();
      
      switch(shape) {
        case 'circle':
          ctx.arc(x, y, size, 0, Math.PI * 2);
          break;
          
        case 'square':
          ctx.rect(x - size, y - size, size * 2, size * 2);
          break;
          
        case 'hexagon':
          for (let i = 0; i < 6; i++) {
            const angle = (Math.PI / 3) * i - Math.PI / 2;
            const px = x + size * Math.cos(angle);
            const py = y + size * Math.sin(angle);
            if (i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
          }
          break;
          
        default:
          // Fallback to circle for any unknown shape
          ctx.arc(x, y, size, 0, Math.PI * 2);
          break;
      }
    }
    
    // Factory function to create a new note with current template settings
    function createNote(x, y) {
      return {
        x: x,
        y: y,
        midiNote: lastNoteTemplate.midiNote,
        noteName: lastNoteTemplate.noteName,
        channel: lastNoteTemplate.channel,
        duration: lastNoteTemplate.duration,
        velocity: lastNoteTemplate.velocity,
        rule: null,
        links: [],
        shape: lastNoteTemplate.shape,
        color: lastNoteTemplate.color,
        size: lastNoteTemplate.size,
        isStart: false,  // New notes are never root notes
        monophonic: lastNoteTemplate.monophonic,
        graph: lastNoteTemplate.graph,
        hold: lastNoteTemplate.hold
      };
    }
    
    // MIDI note conversion utilities
    const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    
    function midiToNoteName(midi) {
      const octave = Math.floor(midi / 12) - 1;
      const note = noteNames[midi % 12];
      return note + octave;
    }
    
    function noteNameToMIDI(name) {
      const match = name.match(/^([A-G])(#|b)?(-?\d+)$/);
      if (!match) return 60; // Default to C4
      
      let [, note, accidental, octave] = match;
      octave = parseInt(octave);
      
      let noteIndex = noteNames.indexOf(note);
      if (noteIndex === -1) return 60;
      
      if (accidental === '#') noteIndex++;
      if (accidental === 'b') noteIndex--;
      
      return (octave + 1) * 12 + noteIndex;
    }
    
    // Generate note name options for dropdown
    function generateNoteOptions() {
      const options = [];
      for (let midi = 21; midi <= 108; midi++) { // Piano range A0 to C8
        options.push({ midi, name: midiToNoteName(midi) });
      }
      return options;
    }
    
    // Agent system
    function spawnAgentsFromStartNotes() {
      agents.length = 0; // Clear existing agents
      
      for (const note of notes.values()) {
        if (note.isStart && note.links.length > 0) {
          // Root notes don't move - they just sit at their position
          // Create a dummy agent that immediately "arrives" to trigger the note's links
          agents.push({
            x: note.x,
            y: note.y,
            targetX: note.x,
            targetY: note.y,
            progress: 1, // Already at target - will trigger on first frame
            currentNote: note,
            targetNote: note,
            color: note.color || settings.noteColor
          });
        }
      }
    }
    
    function triggerNoteSound(note) {
      // Monophonic mode: skip trigger if any note in same graph is playing
      if (note.monophonic) {
        const isPlaying = activeNotes.some(active => 
          active.graph === note.graph
        );
        if (isPlaying) {
          return; // Skip trigger - let existing note in graph ring
        }
      }
      
      // Mark note as just fired for visual feedback
      note.lastFireTime = performance.now();
      
      const channel = note.channel || 0;
      const velocity = note.velocity !== undefined ? note.velocity : 100;
      const durationBeats = note.duration || 0.25;
      const durationMs = durationBeats * (240000 / settings.bpm); // duration is fraction of whole note
      
      if (midi.useWebAudio) {
        audioSynth.playNote(note.midiNote, velocity, durationMs, channel);
      } else {
        midi.sendNote(note.midiNote, velocity, channel);
        
        // Track for note-off timing (only needed for MIDI hardware)
        activeNotes.push({
          midiNote: note.midiNote,
          channel: channel,
          graph: note.graph || 0,
          offTime: performance.now() + durationMs
        });
      }
    }
    
    function triggerRootNotes() {
      // Fire MIDI for all root notes on play
      for (const note of notes.values()) {
        if (note.isStart) {
          triggerNoteSound(note);
        }
      }
    }
    
    function updateAgents(deltaTime) {
      if (isPaused) return;
      
      // Helper to create an agent spawn object
      const createAgentSpawn = (sourceNote, targetNote, phase, agentColor) => ({
        x: sourceNote.x + (targetNote.x - sourceNote.x) * phase,
        y: sourceNote.y + (targetNote.y - sourceNote.y) * phase,
        targetX: targetNote.x,
        targetY: targetNote.y,
        progress: phase,
        currentNote: sourceNote,
        targetNote: targetNote,
        color: agentColor
      });
      
      // Process links using group-based probability algorithm
      // Returns array of agents ready to spawn (one per group that fires)
      const processLinks = (sourceNote, linkArray, agentColor) => {
        const spawns = [];
        
        // Group links by group ID
        const groups = {};
        for (const link of linkArray) {
          const groupId = link.group !== undefined ? link.group : 0;
          if (!groups[groupId]) groups[groupId] = [];
          groups[groupId].push(link);
        }
        
        // Process each group
        for (const groupId in groups) {
          const groupLinks = groups[groupId];
          
          // Build fired list - links that pass probability check
          const fired = [];
          for (const link of groupLinks) {
            const prob = (link.probability !== undefined ? link.probability : 100) / 100;
            if (Math.random() < prob) {
              fired.push(link);
            }
          }
          
          // If any fired, pick one by weight and spawn agent
          if (fired.length > 0) {
            // Weighted random selection from fired links
            const totalWeight = fired.reduce((sum, l) => sum + (l.weight !== undefined ? l.weight : 1), 0);
            let selected = null;
            
            // If all weights are 0, pick uniformly at random
            if (totalWeight === 0) {
              selected = fired[Math.floor(Math.random() * fired.length)];
            } else {
              // Weighted selection
              let random = Math.random() * totalWeight;
              
              for (const link of fired) {
                const weight = link.weight !== undefined ? link.weight : 1;
                random -= weight;
                if (random <= 0) {
                  selected = link;
                  break;
                }
              }
              
              if (!selected) selected = fired[0]; // Fallback
            }
            
            // Spawn agent for selected link
            const targetKey = posKey(selected.x, selected.y);
            const targetNote = notes.get(targetKey);
            if (targetNote) {
              const phase = (selected.phase || 0) / 100;
              spawns.push(createAgentSpawn(sourceNote, targetNote, phase, agentColor));
            }
          }
        }
        
        return spawns;
      };
      
      // Speed: one grid square = one sixteenth note (1/16)
      // At BPM, one quarter note = 60000/BPM ms, so one 1/16 note = (60000/BPM)/4 ms
      const sixteenthNoteDuration = (60000 / settings.bpm) / 4; // ms per 1/16 note
      const speed = gridSpacing / sixteenthNoteDuration; // px per ms
      
      for (let i = agents.length - 1; i >= 0; i--) {
        const agent = agents[i];
        
        // Calculate TOTAL distance from start to target (not current position to target)
        const dx = agent.targetX - agent.currentNote.x;
        const dy = agent.targetY - agent.currentNote.y;
        const totalDistance = Math.sqrt(dx * dx + dy * dy);
        
        if (totalDistance > 0) {
          const progressIncrement = (speed * deltaTime) / totalDistance;
          agent.progress += progressIncrement;
        }
        
        // Check if reached target (either by movement or already there)
        if (agent.progress >= 1) {
            // Reached target note
            agent.progress = 1;
            agent.x = agent.targetX;
            agent.y = agent.targetY;
            
            // Check if agent is holding at note
            if (agent.holdTime !== undefined) {
              // Agent is waiting - update hold timer
              agent.holdTime += deltaTime;
              
              const note = agent.targetNote;
              const holdPercent = (note.hold || 0) / 100;
              const durationBeats = note.duration || 0.25;
              const durationMs = durationBeats * (240000 / settings.bpm);
              const holdDurationMs = durationMs * holdPercent;
              
              if (agent.holdTime >= holdDurationMs) {
                // Hold complete - spawn new agents and die
                const spawns = processLinks(agent.targetNote, agent.targetNote.links, agent.color);
                
                // Trigger sounds for agents spawned at progress>=1 (instant arrival)
                for (const spawn of spawns) {
                  if (spawn.progress >= 1) {
                    triggerNoteSound(spawn.targetNote);
                  }
                }
                
                // All spawns become new agents
                for (const spawn of spawns) {
                  agents.push(spawn);
                }
                
                // Original agent dies
                agents.splice(i, 1);
              }
              // else: continue holding, don't remove agent yet
            } else {
              // Just arrived - trigger note sound
              triggerNoteSound(agent.targetNote);
              
              const note = agent.targetNote;
              const holdPercent = (note.hold || 0) / 100;
              
              if (holdPercent > 0) {
                // Start holding
                agent.holdTime = 0;
                // Don't spawn or remove yet
              } else {
                // No hold - spawn immediately and die
                const spawns = processLinks(agent.targetNote, agent.targetNote.links, agent.color);
                
                // Trigger sounds for agents spawned at progress>=1 (instant arrival)
                for (const spawn of spawns) {
                  if (spawn.progress >= 1) {
                    triggerNoteSound(spawn.targetNote);
                  }
                }
                
                // All spawns become new agents
                for (const spawn of spawns) {
                  agents.push(spawn);
                }
                
                // Original agent dies
                agents.splice(i, 1);
              }
            }
        }
        else if (totalDistance > 0) {
          // Interpolate position from START to TARGET (only if moving)
          agent.x = agent.currentNote.x + (agent.targetX - agent.currentNote.x) * agent.progress;
          agent.y = agent.currentNote.y + (agent.targetY - agent.currentNote.y) * agent.progress;
        }
      }
    }
    
    function drawAgents() {
      for (const agent of agents) {
        const size = settings.agentSize;
        
        // Glowing effect with radial gradient
        const gradient = ctx.createRadialGradient(agent.x, agent.y, 0, agent.x, agent.y, size);
        gradient.addColorStop(0, agent.color);
        gradient.addColorStop(0.5, agent.color + 'aa');
        gradient.addColorStop(1, agent.color + '00');
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(agent.x, agent.y, size, 0, Math.PI * 2);
        ctx.fill();
        
        // Bright center
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(agent.x, agent.y, size / 3, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    
    function posKey(x, y) {
      return `${x},${y}`;
    }
    
    // Sort a note's links by angle (clockwise from top) for predictable arrow key navigation
    function sortNoteLinks(note) {
      if (!note.links || note.links.length <= 1) return; // No sorting needed
      
      note.links.sort((a, b) => {
        // Calculate angles from note to each link target
        const angleA = Math.atan2(a.y - note.y, a.x - note.x);
        const angleB = Math.atan2(b.y - note.y, b.x - note.x);
        return angleA - angleB;
      });
    }
    
    function snapToGrid(x, y) {
      return {
        x: Math.round(x / gridSpacing) * gridSpacing,
        y: Math.round(y / gridSpacing) * gridSpacing
      };
    }
    
    // Transform screen coordinates to world coordinates
    function screenToWorld(screenX, screenY) {
      return {
        x: (screenX - panX) / zoom,
        y: (screenY - panY) / zoom
      };
    }
    
    function getWorldPosition(e) {
      const rect = canvas.getBoundingClientRect();
      const screenX = e.clientX - rect.left;
      const screenY = e.clientY - rect.top;
      return screenToWorld(screenX, screenY);
    }
    
    // Find note at world position (within noteRadius distance)
    function findNoteAt(worldX, worldY) {
      for (const note of notes.values()) {
        const size = note.size || settings.noteSize;
        const dx = note.x - worldX;
        const dy = note.y - worldY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        if (distance <= size) {
          return note;
        }
      }
      return null;
    }
    
    // Find link at world position (within threshold distance to line)
    function findLinkAt(worldX, worldY) {
      const threshold = settings.linkClickThreshold;
      
      // Helper to check if a point is near a link
      const checkLink = (note, link, linkIndex) => {
        const targetKey = posKey(link.x, link.y);
        const targetNote = notes.get(targetKey);
        
        if (!targetNote) return null;
        
        // Calculate distance from point to line segment
        const x1 = note.x;
        const y1 = note.y;
        const x2 = targetNote.x;
        const y2 = targetNote.y;
        
        const C = x2 - x1;
        const D = y2 - y1;
        const lenSq = C * C + D * D;
        
        // If notes are very close (lenSq < 100 = distance < 10px), 
        // just check if click is near midpoint
        if (lenSq < 100) {
          const midX = (x1 + x2) / 2;
          const midY = (y1 + y2) / 2;
          const dx = worldX - midX;
          const dy = worldY - midY;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance <= threshold) {
            return { sourceNote: note, linkIndex: linkIndex, link: link };
          }
          return null;
        }
        
        const A = worldX - x1;
        const B = worldY - y1;
        const dot = A * C + B * D;
        const param = dot / lenSq;
        
        // Only accept hits in the middle third of the line (0.33 to 0.67)
        if (param < 0.33 || param > 0.67) {
          return null;
        }
        
        const xx = x1 + param * C;
        const yy = y1 + param * D;
        
        const dx = worldX - xx;
        const dy = worldY - yy;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance <= threshold) {
          return { sourceNote: note, linkIndex: linkIndex, link: link };
        }
        
        return null;
      };
      
      // Check all notes
      for (const note of notes.values()) {
        for (let i = 0; i < note.links.length; i++) {
          const result = checkLink(note, note.links[i], i);
          if (result) return result;
        }
      }
      
      return null;
    }
    
    // Resize canvas to fit window
    function resizeCanvas() {
      const container = document.getElementById('container');
      canvas.width = container.clientWidth;
      canvas.height = container.clientHeight;
      render();
    }
    
    function drawGrid() {
      ctx.lineWidth = settings.gridLineWidth / zoom;
      
      // Calculate visible world bounds
      const topLeft = screenToWorld(0, 0);
      const bottomRight = screenToWorld(canvas.width, canvas.height);
      
      // Extend grid beyond visible area
      const startX = Math.floor(topLeft.x / gridSpacing) * gridSpacing;
      const endX = Math.ceil(bottomRight.x / gridSpacing) * gridSpacing;
      const startY = Math.floor(topLeft.y / gridSpacing) * gridSpacing;
      const endY = Math.ceil(bottomRight.y / gridSpacing) * gridSpacing;
      
      // Vertical lines (with beat emphasis every 4 lines = quarter note)
      for (let x = startX; x <= endX; x += gridSpacing) {
        const gridIndex = Math.round(x / gridSpacing);
        const isBeatLine = gridIndex % 4 === 0;
        
        if (isBeatLine) {
          ctx.strokeStyle = lightenColor(settings.gridColor, 0.3);
        } else {
          ctx.strokeStyle = settings.gridColor;
        }
        
        ctx.beginPath();
        ctx.moveTo(x, startY);
        ctx.lineTo(x, endY);
        ctx.stroke();
      }
      
      // Horizontal lines (with beat emphasis every 4 lines)
      for (let y = startY; y <= endY; y += gridSpacing) {
        const gridIndex = Math.round(y / gridSpacing);
        const isBeatLine = gridIndex % 4 === 0;
        
        if (isBeatLine) {
          ctx.strokeStyle = lightenColor(settings.gridColor, 0.3);
        } else {
          ctx.strokeStyle = settings.gridColor;
        }
        
        ctx.beginPath();
        ctx.moveTo(startX, y);
        ctx.lineTo(endX, y);
        ctx.stroke();
      }
    }
    
    // Helper to lighten a color
    function lightenColor(color, amount) {
      // Parse hex color
      const hex = color.replace('#', '');
      const r = parseInt(hex.substr(0, 2), 16);
      const g = parseInt(hex.substr(2, 2), 16);
      const b = parseInt(hex.substr(4, 2), 16);
      
      // Lighten
      const nr = Math.min(255, Math.floor(r + (255 - r) * amount));
      const ng = Math.min(255, Math.floor(g + (255 - g) * amount));
      const nb = Math.min(255, Math.floor(b + (255 - b) * amount));
      
      return `#${nr.toString(16).padStart(2, '0')}${ng.toString(16).padStart(2, '0')}${nb.toString(16).padStart(2, '0')}`;
    }
    
    function drawNotes() {
      const arrowSize = settings.arrowSize;
      
      // Helper to draw a single link
      const drawLink = (note, link, color) => {
        const targetKey = posKey(link.x, link.y);
        const targetNote = notes.get(targetKey);
        if (!targetNote) return;
        
        // Check if there's a reverse link (bidirectional)
        const hasReverseLink = targetNote.links.some(l => 
          l.x === note.x && l.y === note.y
        );
        
        let startX = note.x;
        let startY = note.y;
        let endX = targetNote.x;
        let endY = targetNote.y;
        
        // If bidirectional, offset this link to the right of the line direction
        if (hasReverseLink) {
          const dx = endX - startX;
          const dy = endY - startY;
          const len = Math.sqrt(dx * dx + dy * dy);
          
          // Perpendicular offset (right side)
          const perpX = -dy / len * settings.bidirectionalLinkOffset;
          const perpY = dx / len * settings.bidirectionalLinkOffset;
          
          startX += perpX;
          startY += perpY;
          endX += perpX;
          endY += perpY;
        }
        
        // Draw line with provided color
        ctx.strokeStyle = color;
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(endX, endY);
        ctx.stroke();
        
        // Draw arrow head
        const dx = endX - startX;
        const dy = endY - startY;
        const angle = Math.atan2(dy, dx);
        const len = Math.sqrt(dx * dx + dy * dy);
        
        const targetSize = targetNote.size || settings.noteSize;
        
        // Position arrow at edge of target note circle, not center
        const arrowX = startX + (dx / len) * (len - targetSize);
        const arrowY = startY + (dy / len) * (len - targetSize);
        
        ctx.save();
        ctx.setLineDash([]); // Ensure arrow is solid
        ctx.translate(arrowX, arrowY);
        ctx.rotate(angle);
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(-arrowSize, -arrowSize / 2);
        ctx.lineTo(-arrowSize, arrowSize / 2);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      };
      
      // Draw all links
      ctx.lineWidth = settings.linkLineWidth;
      ctx.setLineDash([]); // Solid
      
      const phaseIndicators = []; // Collect phase indicators to draw last
      
      for (const note of notes.values()) {
        for (const link of note.links) {
          const targetKey = posKey(link.x, link.y);
          const targetNote = notes.get(targetKey);
          if (!targetNote) continue;
          
          // Calculate link positions (same logic as drawLink)
          const hasReverseLink = targetNote.links.some(l => 
            l.x === note.x && l.y === note.y
          );
          
          let startX = note.x;
          let startY = note.y;
          let endX = targetNote.x;
          let endY = targetNote.y;
          
          if (hasReverseLink) {
            const dx = endX - startX;
            const dy = endY - startY;
            const len = Math.sqrt(dx * dx + dy * dy);
            const perpX = -dy / len * settings.bidirectionalLinkOffset;
            const perpY = dx / len * settings.bidirectionalLinkOffset;
            startX += perpX;
            startY += perpY;
            endX += perpX;
            endY += perpY;
          }
          
          // Calculate link color based on probability (0% = darker, 100% = white)
          const prob = (link.probability !== undefined ? link.probability : 100) / 100;
          const brightness = Math.round(
            settings.linkProbabilityMinBrightness + 
            prob * (settings.linkProbabilityMaxBrightness - settings.linkProbabilityMinBrightness)
          );
          const linkColor = `rgb(${brightness}, ${brightness}, ${brightness})`;
          
          drawLink(note, link, linkColor);
          
          // Store phase indicator data for later
          const phase = (link.phase || 0) / 100;
          if (phase > 0) {
            // Calculate arrow position (where link meets target note edge)
            const dx = endX - startX;
            const dy = endY - startY;
            const len = Math.sqrt(dx * dx + dy * dy);
            const targetSize = targetNote.size || settings.noteSize;
            const phaseIndicatorRadius = settings.phaseIndicatorRadius;
            
            // Clamp phase to arrow position minus indicator radius
            const maxPhase = len > 0 ? (len - targetSize - phaseIndicatorRadius) / len : 1;
            const clampedPhase = Math.min(phase, maxPhase);
            
            phaseIndicators.push({
              x: startX + (endX - startX) * clampedPhase,
              y: startY + (endY - startY) * clampedPhase,
              color: linkColor
            });
          }
        }
      }
      
      // Draw phase indicators last (on top of arrows)
      for (const indicator of phaseIndicators) {
        ctx.fillStyle = indicator.color;
        ctx.beginPath();
        ctx.arc(indicator.x, indicator.y, 4, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Draw link being created
      if (linkingFromNote && linkingMousePos) {
        ctx.strokeStyle = settings.linkColor;
        ctx.lineWidth = settings.linkLineWidth;
        ctx.setLineDash(settings.linkCreatingDashPattern);
        ctx.beginPath();
        ctx.moveTo(linkingFromNote.x, linkingFromNote.y);
        ctx.lineTo(linkingMousePos.x, linkingMousePos.y);
        ctx.stroke();
        ctx.setLineDash([]);
      }
      
      // Draw notes on top
      for (const note of notes.values()) {
        ctx.save(); // Isolate canvas state for each note
        
        const shape = note.shape || settings.noteShape;
        const color = note.color || settings.noteColor;
        const size = note.size || settings.noteSize;
        
        ctx.fillStyle = color;
        ctx.strokeStyle = color;
        ctx.lineWidth = settings.noteStrokeWidth;
        
        // Check if note recently fired and should flash
        const now = performance.now();
        const timeSinceFire = note.lastFireTime ? now - note.lastFireTime : Infinity;
        const isFlashing = timeSinceFire < settings.noteFireFlashDuration;
        
        drawNoteShape(ctx, note.x, note.y, size, shape);
        ctx.fill();
        ctx.stroke();
        
        // Draw bright flash if recently fired
        if (isFlashing) {
          ctx.save();
          ctx.globalAlpha = 1 - (timeSinceFire / settings.noteFireFlashDuration); // Fade out
          ctx.fillStyle = settings.noteFireFlashColor;
          ctx.strokeStyle = settings.noteFireFlashColor;
          ctx.lineWidth = settings.noteStrokeWidth * settings.noteFireFlashBrightness;
          drawNoteShape(ctx, note.x, note.y, size * settings.noteFireFlashBrightness, shape);
          ctx.fill();
          ctx.stroke();
          ctx.restore();
        }
        
        // Draw outer outline for root notes
        if (note.isStart) {
          ctx.strokeStyle = color;
          ctx.lineWidth = settings.noteStrokeWidth;
          drawNoteShape(ctx, note.x, note.y, size + 3, shape);
          ctx.stroke();
        }
        
        // Highlight if this is the source of a link being created
        if (linkingFromNote === note) {
          ctx.strokeStyle = '#6a6a6a';
          ctx.lineWidth = settings.noteRootStrokeWidth;
          ctx.stroke();
          ctx.strokeStyle = color; // Restore
          ctx.lineWidth = settings.noteStrokeWidth;
        }
        
        ctx.restore(); // Restore canvas state after each note
      }
    }
    
    // Properties sidebar management
    const propertiesContent = document.getElementById('properties-content');
    
    // Use existing colorPalette and noteNames from top of file
    
    function updatePropertiesSidebar() {
      if (selectedNote) {
        showNoteProperties(selectedNote);
      } else if (selectedLink) {
        showLinkProperties(selectedLink);
      } else {
        showDefaultProperties();
      }
    }
    
    function showNoteProperties(note) {
      const midiNote = note.midiNote || 60;
      const octave = Math.floor(midiNote / 12) - 1;
      const noteIndex = midiNote % 12;
      
      propertiesContent.innerHTML = `
        <h3>Note Properties</h3>
        
        <!-- MIDI PROPERTIES -->
        <div class="property-section">
          <div class="property-label">Pitch</div>
          <div class="note-grid">
            ${noteNames.map((name, i) => `
              <button class="note-btn ${i === noteIndex ? 'selected' : ''}" data-note="${i}">${name}</button>
            `).join('')}
          </div>
          <div class="octave-selector">
            ${[0, 1, 2, 3, 4, 5, 6, 7, 8].map(oct => `
              <button class="octave-btn ${oct === octave ? 'selected' : ''}" data-octave="${oct}">${oct}</button>
            `).join('')}
          </div>
        </div>
        
        <div class="property-section">
          <div class="property-label">Duration</div>
          <select class="property-select" data-property="duration">
            <option value="0.0078125" ${(note.duration || 0.25) === 0.0078125 ? 'selected' : ''}>1/128</option>
            <option value="0.015625" ${(note.duration || 0.25) === 0.015625 ? 'selected' : ''}>1/64</option>
            <option value="0.03125" ${(note.duration || 0.25) === 0.03125 ? 'selected' : ''}>1/32</option>
            <option value="0.0625" ${(note.duration || 0.25) === 0.0625 ? 'selected' : ''}>1/16</option>
            <option value="0.125" ${(note.duration || 0.25) === 0.125 ? 'selected' : ''}>1/8</option>
            <option value="0.25" ${(note.duration || 0.25) === 0.25 ? 'selected' : ''}>1/4</option>
            <option value="0.5" ${(note.duration || 0.25) === 0.5 ? 'selected' : ''}>1/2</option>
            <option value="1.0" ${(note.duration || 0.25) === 1.0 ? 'selected' : ''}>1</option>
            <option value="2.0" ${(note.duration || 0.25) === 2.0 ? 'selected' : ''}>2</option>
            <option value="4.0" ${(note.duration || 0.25) === 4.0 ? 'selected' : ''}>4</option>
            <option value="8.0" ${(note.duration || 0.25) === 8.0 ? 'selected' : ''}>8</option>
            <option value="16.0" ${(note.duration || 0.25) === 16.0 ? 'selected' : ''}>16</option>
            <option value="32.0" ${(note.duration || 0.25) === 32.0 ? 'selected' : ''}>32</option>
            <option value="64.0" ${(note.duration || 0.25) === 64.0 ? 'selected' : ''}>64</option>
            <option value="128.0" ${(note.duration || 0.25) === 128.0 ? 'selected' : ''}>128</option>
          </select>
        </div>
        
        <div class="property-section">
          <div class="property-label">Velocity</div>
          <input type="range" class="property-slider" min="0" max="127" step="1" 
                 value="${note.velocity !== undefined ? note.velocity : 100}" data-property="velocity">
          <div class="property-value">${note.velocity !== undefined ? note.velocity : 100}</div>
        </div>
        
        <div class="property-section">
          <div class="property-label">Channel</div>
          <input type="range" class="property-slider" min="0" max="15" step="1" 
                 value="${note.channel || 0}" data-property="channel">
          <div class="property-value">${note.channel || 0}</div>
        </div>
        
        <!-- CONTROL PROPERTIES -->
        <div class="property-section" style="margin-top: 20px; border-top: 1px solid #333; padding-top: 12px;">
          <div class="property-label">Hold</div>
          <input type="range" class="property-slider" min="0" max="100" step="1" 
                 value="${note.hold || 0}" data-property="hold">
          <div class="property-value">${note.hold || 0}%</div>
        </div>
        
        <div class="property-section">
          <div class="property-label">Monophonic</div>
          <input type="range" class="property-slider" style="width: 12.5%;" min="0" max="1" step="1" 
                 value="${note.monophonic ? 1 : 0}" data-property="monophonic">
          <div class="property-value">${note.monophonic ? 1 : 0}</div>
        </div>
        
        <div class="property-section">
          <div class="property-label">Graph</div>
          <input type="range" class="property-slider" min="0" max="10" step="1" 
                 value="${note.graph || 0}" data-property="graph">
          <div class="property-value">${note.graph || 0}</div>
        </div>
        
        <!-- STYLE PROPERTIES -->
        <div class="property-section" style="margin-top: 20px; border-top: 1px solid #333; padding-top: 12px;">
          <div class="property-label">Color</div>
          <div class="color-grid" style="display: grid; grid-template-columns: repeat(4, ${settings.colorSwatchSize}px); gap: 4px; justify-content: center; margin-top: 8px;">
            ${colorPalette.map((color, i) => `
              <div class="color-swatch ${color === (note.color || settings.noteColor) ? 'selected' : ''}" 
                   data-color="${color}"
                   style="width: ${settings.colorSwatchSize}px; 
                          height: ${settings.colorSwatchSize}px; 
                          background: ${color}; 
                          border: 2px solid ${color === (note.color || settings.noteColor) ? '#fff' : '#444'};
                          border-radius: 3px;
                          cursor: pointer;
                          transition: all 0.1s;">
              </div>
            `).join('')}
          </div>
        </div>
        
        <div class="property-section">
          <div class="property-label">Size</div>
          <input type="range" class="property-slider" min="${settings.noteMinSize}" max="${settings.noteMaxSize}" step="1" 
                 value="${note.size || settings.noteSize}" data-property="size">
          <div class="property-value">${note.size || settings.noteSize}</div>
        </div>
        
        <div class="property-section">
          <div class="property-label">Shape</div>
          <input type="range" class="property-slider" min="0" max="2" step="1" 
                 value="${['circle', 'square', 'hexagon'].indexOf(note.shape || 'circle')}" 
                 data-property="shape">
          <div class="property-value">${note.shape || 'circle'}</div>
        </div>
        
        <!-- ACTION BUTTONS -->
        <div class="property-section" style="margin-top: 20px; border-top: 1px solid #333; padding-top: 12px;">
          <button class="property-button property-button-warning" data-action="clear-links">Clear Links</button>
          <button class="property-button property-button-danger" data-action="delete-note">Delete Note</button>
        </div>
      `;
      
      attachNotePropertyHandlers(note);
    }
    
    function showLinkProperties(linkData) {
      const link = linkData.link;
      
      propertiesContent.innerHTML = `
        <h3>Link Properties</h3>
        
        <div class="property-section">
          <div class="property-label">Probability</div>
          <input type="range" class="property-slider" min="0" max="100" step="1" 
                 value="${link.probability !== undefined ? link.probability : 100}" data-property="probability">
          <div class="property-value">${link.probability !== undefined ? link.probability : 100}%</div>
        </div>
        
        <div class="property-section">
          <div class="property-label">Group</div>
          <input type="range" class="property-slider" min="0" max="${settings.linkMaxGroups}" step="1" 
                 value="${link.group !== undefined ? link.group : 0}" data-property="group">
          <div class="property-value">${link.group !== undefined ? link.group : 0}</div>
        </div>
        
        <div class="property-section">
          <div class="property-label">Weight Coarse</div>
          <input type="range" class="property-slider" min="0" max="${settings.linkMaxWeight}" step="1" 
                 value="${link.weight !== undefined ? link.weight : 1}" data-property="weight">
        </div>
        
        <div class="property-section" style="margin-top: 4px;">
          <div class="property-label">Weight Fine</div>
          <input type="range" class="property-slider" min="-10" max="10" step="1" 
                 value="0" data-property="weightFine">
          <div class="property-value">${link.weight !== undefined ? link.weight : 1}</div>
        </div>
        
        <div class="property-section">
          <div class="property-label">Phase</div>
          <input type="range" class="property-slider" min="0" max="100" step="1" 
                 value="${link.phase || 0}" data-property="phase">
          <div class="property-value">${link.phase || 0}%</div>
        </div>
        
        <div class="property-section" style="margin-top: 20px; border-top: 1px solid #333; padding-top: 12px;">
          <button class="property-button property-button-danger" data-action="delete-link">Delete Link</button>
        </div>
      `;
      
      attachLinkPropertyHandlers(linkData);
    }
    
    function showDefaultProperties() {
      propertiesContent.innerHTML = `
        <h3>Sequencer</h3>
        
        <div class="property-section">
          <div class="property-label">Name</div>
          <input type="text" id="model-name" value="${modelName}" 
                 style="width: 95%; padding: 6px; background: #2a2a2a; border: 1px solid #444; 
                        border-radius: 3px; color: #ccc; font-family: monospace; font-size: 12px;">
        </div>
        
        <div class="property-section">
          <div class="property-label">Description</div>
          <textarea id="model-description" rows="8"
                    style="width: 95%; padding: 6px; background: #2a2a2a; border: 1px solid #444; 
                           border-radius: 3px; color: #ccc; font-family: monospace; font-size: 12px; 
                           resize: vertical;">${modelDescription}</textarea>
        </div>
        
        <div style="margin-top: 20px; padding-top: 12px; border-top: 1px solid #333; color: #666; font-size: 11px; line-height: 1.5;">
          <p style="margin: 0 0 8px 0; font-weight: bold; color: #888;">SHORTCUTS</p>
          <p style="margin: 0 0 4px 0;">Double-click: new note</p>
          <p style="margin: 0 0 4px 0;">Double-click note: toggle root</p>
          <p style="margin: 0 0 4px 0;">Ctrl+drag from note: new link</p>
          <p style="margin: 0 0 4px 0;">Alt+drag: zoom</p>
          <p style="margin: 0 0 4px 0;">Shift+drag: pan</p>
          <p style="margin: 0 0 4px 0;">←/→: cycle selection</p>
          <p style="margin: 0 0 4px 0;">Tab: toggle notes/links ←/→</p>
          <p style="margin: 0 0 4px 0;">Delete: remove selected</p>
          <p style="margin: 0;">Esc: deselect</p>
        </div>

        <div style="margin-top: 20px; padding-top: 12px; border-top: 1px solid #333; color: #666; font-size: 11px; line-height: 1.5;">
          <p style="margin: 0 0 8px 0; font-weight: bold; color: #888;">VERSION</p>
          <p style="margin: 0 0 4px 0;">${settings.version}</p>
        </div>
      `;
      
      // Attach handlers
      const nameInput = document.getElementById('model-name');
      const descInput = document.getElementById('model-description');
      
      nameInput.addEventListener('input', () => {
        modelName = nameInput.value;
      });
      
      descInput.addEventListener('input', () => {
        modelDescription = descInput.value;
      });
    }
    
    function showChannelSettings(channel) {
      const ch = settings.synthChannels[channel];
      
      propertiesContent.innerHTML = `
        <h3>Web Audio Channel ${channel}</h3>
        
        <div class="property-section">
          <div class="property-label">Oscillator Type</div>
          <input type="range" class="property-slider" min="0" max="4" step="1" 
                 value="${['sine', 'triangle', 'square', 'sawtooth', 'noise'].indexOf(ch.oscillatorType)}" 
                 data-property="oscillatorType" data-channel="${channel}">
          <div class="property-value">${ch.oscillatorType}</div>
        </div>
        
        <div class="property-section">
          <div class="property-label">Volume</div>
          <input type="range" class="property-slider" min="0" max="1" step="0.01" 
                 value="${ch.volume}" 
                 data-property="volume" data-channel="${channel}">
          <div class="property-value">${ch.volume.toFixed(2)}</div>
        </div>
        
        <div class="property-section" style="margin-top: 20px; border-top: 1px solid #333; padding-top: 12px;">
          <div class="property-label">Attack</div>
          <input type="range" class="property-slider" min="0" max="1" step="0.01" 
                 value="${ch.attack}" 
                 data-property="attack" data-channel="${channel}">
          <div class="property-value">${ch.attack.toFixed(2)}s</div>
        </div>
        
        <div class="property-section">
          <div class="property-label">Decay</div>
          <input type="range" class="property-slider" min="0" max="1" step="0.01" 
                 value="${ch.decay}" 
                 data-property="decay" data-channel="${channel}">
          <div class="property-value">${ch.decay.toFixed(2)}s</div>
        </div>
        
        <div class="property-section">
          <div class="property-label">Sustain</div>
          <input type="range" class="property-slider" min="0" max="1" step="0.01" 
                 value="${ch.sustain}" 
                 data-property="sustain" data-channel="${channel}">
          <div class="property-value">${ch.sustain.toFixed(2)}</div>
        </div>
        
        <div class="property-section">
          <div class="property-label">Release</div>
          <input type="range" class="property-slider" min="0" max="1" step="0.01" 
                 value="${ch.release}" 
                 data-property="release" data-channel="${channel}">
          <div class="property-value">${ch.release.toFixed(2)}s</div>
        </div>
        
        <div class="property-section" style="margin-top: 20px; border-top: 1px solid #333; padding-top: 12px;">
          <div class="property-label">Filter Enabled</div>
          <input type="range" class="property-slider" style="width: 12.5%;" min="0" max="1" step="1" 
                 value="${ch.filterEnabled ? 1 : 0}" data-property="filterEnabled" data-channel="${channel}">
          <div class="property-value">${ch.filterEnabled ? 1 : 0}</div>
        </div>
        
        <div class="property-section">
          <div class="property-label">Filter Multiplier</div>
          <input type="range" class="property-slider" min="1" max="10" step="0.1" 
                 value="${ch.filterMultiplier}" 
                 data-property="filterMultiplier" data-channel="${channel}">
          <div class="property-value">${ch.filterMultiplier.toFixed(1)}</div>
        </div>
        
        <div class="property-section">
          <div class="property-label">Filter Q</div>
          <input type="range" class="property-slider" min="0.1" max="10" step="0.1" 
                 value="${ch.filterQ}" 
                 data-property="filterQ" data-channel="${channel}">
          <div class="property-value">${ch.filterQ.toFixed(1)}</div>
        </div>
      `;
      
      attachChannelPropertyHandlers(channel);
    }
    
    function attachChannelPropertyHandlers(channel) {
      const ch = settings.synthChannels[channel];
      
      // Checkboxes
      propertiesContent.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
        checkbox.addEventListener('change', () => {
          const prop = checkbox.dataset.property;
          ch[prop] = checkbox.checked;
          render();
        });
      });
      
      // Sliders
      propertiesContent.querySelectorAll('.property-slider').forEach(slider => {
        const updateValue = () => {
          const prop = slider.dataset.property;
          const value = parseFloat(slider.value);
          
          // Special handling for oscillatorType
          if (prop === 'oscillatorType') {
            const types = ['sine', 'triangle', 'square', 'sawtooth', 'noise'];
            ch[prop] = types[value];
            const valueDisplay = slider.nextElementSibling;
            valueDisplay.textContent = types[value];
          } else if (prop === 'filterEnabled') {
            // Convert 0/1 to boolean
            ch[prop] = value === 1;
            const valueDisplay = slider.nextElementSibling;
            valueDisplay.textContent = value;
          } else {
            ch[prop] = value;
            const valueDisplay = slider.nextElementSibling;
            
            // Format display
            if (prop === 'volume' || prop === 'sustain') {
              valueDisplay.textContent = value.toFixed(2);
            } else if (prop === 'attack' || prop === 'decay' || prop === 'release') {
              valueDisplay.textContent = value.toFixed(2) + 's';
            } else {
              valueDisplay.textContent = value.toFixed(1);
            }
          }
          
          render();
        };
        
        slider.addEventListener('input', updateValue);
        slider.addEventListener('change', updateValue);
      });
    }
    
    function formatDuration(beats) {
      // Long durations (drones)
      if (beats >= 128) return '128';
      if (beats >= 64) return '64';
      if (beats >= 32) return '32';
      if (beats >= 16) return '16';
      if (beats >= 8) return '8';
      if (beats >= 4) return '4';
      if (beats >= 2) return '2';
      if (beats >= 1) return '1';
      // Standard durations
      if (beats >= 0.5) return '1/2';
      if (beats >= 0.25) return '1/4';
      if (beats >= 0.125) return '1/8';
      if (beats >= 0.0625) return '1/16';
      // Short durations (triggers)
      if (beats >= 0.03125) return '1/32';
      if (beats >= 0.015625) return '1/64';
      return '1/128';
    }
    
    function formatPropertyValue(prop, value) {
      if (prop === 'duration') return formatDuration(value);
      if (prop === 'phase') return `${value}%`;
      if (prop === 'probability') return `${value}%`;
      if (prop === 'hold') return `${value}%`;
      return value;
    }
    
    function updateNoteTemplate(note) {
      lastNoteTemplate = {
        midiNote: note.midiNote,
        noteName: note.noteName,
        channel: note.channel,
        duration: note.duration,
        velocity: note.velocity,
        shape: note.shape,
        color: note.color,
        size: note.size,
        monophonic: note.monophonic,
        graph: note.graph,
        hold: note.hold
      };
    }
    
    function updateLinkTemplate(link) {
      lastLinkTemplate = {
        weight: link.weight,
        probability: link.probability,
        group: link.group,
        phase: link.phase
      };
    }
    
    function attachNotePropertyHandlers(note) {
      // Note selection
      propertiesContent.querySelectorAll('.note-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const noteIndex = parseInt(btn.dataset.note);
          const octave = Math.floor(note.midiNote / 12) - 1;
          note.midiNote = (octave + 1) * 12 + noteIndex;
          note.noteName = midiToNoteName(note.midiNote);
          updateNoteTemplate(note);
          
          // Update button states
          propertiesContent.querySelectorAll('.note-btn').forEach(b => b.classList.remove('selected'));
          btn.classList.add('selected');
          
          render();
        });
      });
      
      // Octave selection
      propertiesContent.querySelectorAll('.octave-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const octave = parseInt(btn.dataset.octave);
          const noteIndex = note.midiNote % 12;
          note.midiNote = (octave + 1) * 12 + noteIndex;
          note.noteName = midiToNoteName(note.midiNote);
          updateNoteTemplate(note);
          
          // Update button states
          propertiesContent.querySelectorAll('.octave-btn').forEach(b => b.classList.remove('selected'));
          btn.classList.add('selected');
          
          render();
        });
      });
      
      // Color swatches
      propertiesContent.querySelectorAll('.color-swatch').forEach(swatch => {
        swatch.addEventListener('click', () => {
          note.color = swatch.dataset.color;
          
          // Update swatch borders
          propertiesContent.querySelectorAll('.color-swatch').forEach(s => {
            s.style.border = `2px solid ${s.dataset.color === note.color ? '#fff' : '#444'}`;
            if (s.dataset.color === note.color) {
              s.classList.add('selected');
            } else {
              s.classList.remove('selected');
            }
          });
          
          updateNoteTemplate(note);
          render();
        });
      });
      
      // Sliders
      propertiesContent.querySelectorAll('.property-slider').forEach(slider => {
        const updateValue = () => {
          const prop = slider.dataset.property;
          const value = parseFloat(slider.value);
          
          // Special handling for shape property
          if (prop === 'shape') {
            const shapes = ['circle', 'square', 'hexagon'];
            note[prop] = shapes[value];
            const valueDisplay = slider.nextElementSibling;
            valueDisplay.textContent = shapes[value];
          } else if (prop === 'monophonic') {
            // Convert 0/1 to boolean
            note[prop] = value === 1;
            const valueDisplay = slider.nextElementSibling;
            valueDisplay.textContent = value;
          } else {
            note[prop] = value;
            const valueDisplay = slider.nextElementSibling;
            valueDisplay.textContent = formatPropertyValue(prop, value);
          }
          
          updateNoteTemplate(note);
          render();
        };
        
        slider.addEventListener('input', updateValue);
      });
      
      // Select dropdowns
      propertiesContent.querySelectorAll('.property-select').forEach(select => {
        select.addEventListener('change', () => {
          const prop = select.dataset.property;
          note[prop] = parseFloat(select.value);
          updateNoteTemplate(note);
          render();
        });
      });
      
      // Checkboxes
      propertiesContent.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
        checkbox.addEventListener('change', () => {
          const prop = checkbox.dataset.property;
          note[prop] = checkbox.checked;
          updateNoteTemplate(note);
          render();
        });
      });
      
      // Action buttons
      propertiesContent.querySelectorAll('[data-action]').forEach(btn => {
        btn.addEventListener('click', () => {
          const action = btn.dataset.action;
          if (action === 'delete-note') {
            const key = posKey(note.x, note.y);
            
            // Remove all links pointing TO this note from other notes
            for (const otherNote of notes.values()) {
              otherNote.links = otherNote.links.filter(link => 
                !(link.x === note.x && link.y === note.y)
              );
            }
            
            // Delete the note itself
            notes.delete(key);
            selectedNote = null;
            updatePropertiesSidebar();
            render();
          } else if (action === 'clear-links') {
            note.links = [];
            render();
          }
        });
      });
    }
    
    function attachLinkPropertyHandlers(linkData) {
      const link = linkData.link;
      
      // Sliders
      propertiesContent.querySelectorAll('.property-slider').forEach(slider => {
        const prop = slider.dataset.property;
        
        // Special handling for Weight Fine
        if (prop === 'weightFine') {
          slider.addEventListener('input', () => {
            const adjustment = parseInt(slider.value);
            const coarseSlider = propertiesContent.querySelector('[data-property="weight"]');
            const newWeight = Math.max(0, Math.min(settings.linkMaxWeight, link.weight + adjustment));
            
            // Update coarse slider and value display (which is below fine slider)
            coarseSlider.value = newWeight;
            slider.nextElementSibling.textContent = newWeight;
          });
          
          slider.addEventListener('change', () => {
            const adjustment = parseInt(slider.value);
            const coarseSlider = propertiesContent.querySelector('[data-property="weight"]');
            const newWeight = Math.max(0, Math.min(settings.linkMaxWeight, link.weight + adjustment));
            
            // Commit the change
            link.weight = newWeight;
            coarseSlider.value = newWeight;
            slider.nextElementSibling.textContent = newWeight;
            
            // Reset fine slider to 0 (no visible display to reset)
            slider.value = 0;
            
            updateLinkTemplate(link);
            render();
          });
        } else {
          // Normal slider handling
          const updateValue = () => {
            const value = parseInt(slider.value);
            link[prop] = value;
            
            const valueDisplay = slider.nextElementSibling;
            valueDisplay.textContent = formatPropertyValue(prop, value);
            updateLinkTemplate(link);
            render();
          };
          
          slider.addEventListener('input', updateValue);
        }
      });
      
      // Action buttons
      propertiesContent.querySelectorAll('[data-action]').forEach(btn => {
        btn.addEventListener('click', () => {
          const action = btn.dataset.action;
          if (action === 'delete-link') {
            linkData.sourceNote.links.splice(linkData.linkIndex, 1);
            selectedLink = null;
            updatePropertiesSidebar();
            render();
          }
        });
      });
    }
    
    // Save/Load functionality
    function saveSequence() {
      const data = {
        version: settings.version,
        notes: Array.from(notes.entries()).map(([key, note]) => {
          // Create a clean copy without runtime properties
          const { lastFireTime, ...cleanNote } = note;
          return {
            key: key,
            note: cleanNote
          };
        }),
        metadata: {
          name: modelName,
          description: modelDescription
        },
        settings: {
          bpm: settings.bpm,
          theme: settings.theme
        },
        camera: {
          panX: panX,
          panY: panY,
          zoom: zoom
        }
      };
      
      const json = JSON.stringify(data, null, 2);
      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      // Use modelName for filename, sanitize and add timestamp if empty
      const safeName = modelName.trim() || 'Untitled';
      const filename = safeName.replace(/[^a-z0-9_\-]/gi, '_').toLowerCase();
      //a.download = `${filename}-${Date.now()}.json`;
      a.download = `${filename}.json`;
      a.click();
      URL.revokeObjectURL(url);
      
      console.log('Sequence saved');
    }
    
    function loadSequence() {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.json';
      input.onchange = (e) => {
        const file = e.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = (event) => {
          try {
            const data = JSON.parse(event.target.result);
            
            // Clear current state
            notes.clear();
            agents.length = 0;
            selectedNote = null;
            selectedLink = null;
            
            // Restore notes
            if (data.notes) {
              for (const item of data.notes) {
                const note = item.note;
                
                // Normalize note properties with defaults
                if (!note.color) note.color = settings.noteColor;
                if (!note.shape) note.shape = 'circle';
                if (note.size === undefined) note.size = settings.noteSize;
                if (note.velocity === undefined) note.velocity = 64;
                if (note.duration === undefined) note.duration = 0.25;
                if (note.channel === undefined) note.channel = 0;
                if (note.hold === undefined) note.hold = 0;
                if (note.graph === undefined) note.graph = 0;
                if (note.monophonic === undefined) note.monophonic = false;
                if (!note.links) note.links = [];
                
                // Normalize link properties with defaults
                for (const link of note.links) {
                  if (link.weight === undefined) link.weight = 1;
                  if (link.probability === undefined) link.probability = 100;
                  if (link.group === undefined) link.group = 0;
                  if (link.phase === undefined) link.phase = 0;
                }
                
                // Remove runtime-only properties that shouldn't be loaded
                delete note.lastFireTime;
                
                notes.set(item.key, note);
              }
            }
            
            // Restore metadata
            if (data.metadata) {
              modelName = data.metadata.name || 'Untitled';
              modelDescription = data.metadata.description || '';
            } else {
              modelName = 'Untitled';
              modelDescription = '';
            }
            
            // Restore settings
            if (data.settings) {
              if (data.settings.bpm) settings.bpm = data.settings.bpm;
              if (data.settings.theme) applyTheme(data.settings.theme);
            }
            
            // Restore camera
            if (data.camera) {
              panX = data.camera.panX || 0;
              panY = data.camera.panY || 0;
              zoom = data.camera.zoom || 1;
            }
            
            // Show default properties with loaded metadata
            selectedNote = null;
            selectedLink = null;
            updatePropertiesSidebar();
            render();
            
            console.log('Sequence loaded');
          } catch (err) {
            console.error('Failed to load sequence:', err);
            alert('Failed to load sequence file');
          }
        };
        reader.readAsText(file);
      };
      input.click();
    }
          
    function drawSelectionBox() {
      ctx.strokeStyle = settings.selectionBoxColor;
      ctx.lineWidth = settings.selectionBoxLineWidth;
      ctx.setLineDash(settings.selectionBoxDashPattern);
      
      if (selectedNote) {
        // Draw box around selected note
        const size = selectedNote.size || settings.noteSize;
        const boxSize = size * 2 + settings.selectionBoxPaddingNote;
        const centerX = selectedNote.x;
        const centerY = selectedNote.y;
        
        ctx.strokeRect(
          centerX - boxSize / 2,
          centerY - boxSize / 2,
          boxSize,
          boxSize
        );
        
        // Draw X marker at center
        const xSize = settings.selectionBoxXSize;
        ctx.beginPath();
        ctx.moveTo(centerX - xSize / 2, centerY - xSize / 2);
        ctx.lineTo(centerX + xSize / 2, centerY + xSize / 2);
        ctx.moveTo(centerX + xSize / 2, centerY - xSize / 2);
        ctx.lineTo(centerX - xSize / 2, centerY + xSize / 2);
        ctx.stroke();
        
      } else if (selectedLink) {
        // Draw box around selected link center
        const sourceNote = selectedLink.sourceNote;
        const link = selectedLink.link;
        const targetKey = posKey(link.x, link.y);
        const targetNote = notes.get(targetKey);
        
        if (targetNote) {
          // Calculate actual drawn link position (with bidirectional offset)
          const hasReverseLink = targetNote.links.some(l => 
            l.x === sourceNote.x && l.y === sourceNote.y
          );
          
          let startX = sourceNote.x;
          let startY = sourceNote.y;
          let endX = targetNote.x;
          let endY = targetNote.y;
          
          if (hasReverseLink) {
            const dx = endX - startX;
            const dy = endY - startY;
            const len = Math.sqrt(dx * dx + dy * dy);
            
            const perpX = -dy / len * settings.bidirectionalLinkOffset;
            const perpY = dx / len * settings.bidirectionalLinkOffset;
            
            startX += perpX;
            startY += perpY;
            endX += perpX;
            endY += perpY;
          }
          
          // Calculate link length and center
          const dx = endX - startX;
          const dy = endY - startY;
          const linkLength = Math.sqrt(dx * dx + dy * dy);
          const centerX = (startX + endX) / 2;
          const centerY = (startY + endY) / 2;
          
          // Box size is proportional to link length
          const boxSize = linkLength * settings.linkSelectionBoxScale;
          
          ctx.strokeRect(
            centerX - boxSize / 2,
            centerY - boxSize / 2,
            boxSize,
            boxSize
          );
          
          // Draw X marker at center
          const xSize = settings.selectionBoxXSize;
          ctx.beginPath();
          ctx.moveTo(centerX - xSize / 2, centerY - xSize / 2);
          ctx.lineTo(centerX + xSize / 2, centerY + xSize / 2);
          ctx.moveTo(centerX + xSize / 2, centerY - xSize / 2);
          ctx.lineTo(centerX - xSize / 2, centerY + xSize / 2);
          ctx.stroke();
        }
      }
      
      ctx.setLineDash([]); // Reset to solid
    }
    
    
    function render() {
      // Clear
      ctx.fillStyle = settings.backgroundColor;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Apply camera transform
      ctx.save();
      ctx.translate(panX, panY);
      ctx.scale(zoom, zoom);
      
      drawGrid();
      drawNotes();
      drawAgents(); // Draw agents on top of notes
      drawSelectionBox(); // Draw selection indicator on top
      
      ctx.restore();
    }
    
    // Animation loop
    function updateLoop(timestamp) {
      if (isPlaying) {
        const deltaTime = lastFrameTime ? timestamp - lastFrameTime : 0;
        lastFrameTime = timestamp;
        
        // Process note-offs (only needed for MIDI hardware)
        if (!midi.useWebAudio) {
          const now = performance.now();
          for (let i = activeNotes.length - 1; i >= 0; i--) {
            if (now >= activeNotes[i].offTime) {
              midi.sendNoteOff(activeNotes[i].midiNote, activeNotes[i].channel);
              activeNotes.splice(i, 1);
            }
          }
        }
        
        // Update beat counter in B:Q:S format (Bar:Quarter:Sixteenth)
        if (!isPaused) {
          const elapsedTime = timestamp - playStartTime; // ms since play started
          const sixteenthNoteDuration = (60000 / settings.bpm) / 4; // ms per 1/16 note
          const totalSixteenths = Math.floor(elapsedTime / sixteenthNoteDuration);
          
          // Calculate B:Q:S (hardcoded to 4/4 time for now)
          const sixteenthsPerBar = 16; // 4 beats * 4 sixteenths = 16 sixteenths per bar
          const bar = Math.floor(totalSixteenths / sixteenthsPerBar) + 1; // Bars start at 1
          const sixteenthInBar = totalSixteenths % sixteenthsPerBar;
          const quarter = Math.floor(sixteenthInBar / 4) + 1; // Quarters 1-4
          const sixteenth = (sixteenthInBar % 4) + 1; // Sixteenths 1-4
          
          // Update display
          const beatValue = document.getElementById('beat-value');
          beatValue.textContent = `${bar}:${quarter}:${sixteenth}`;
          
          // Update graph counter (notes:links:agents)
          const totalLinks = Array.from(notes.values()).reduce((sum, note) => sum + note.links.length, 0);
          const graphValue = document.getElementById('graph-value');
          graphValue.textContent = `${notes.size}:${totalLinks}:${agents.length}`;
        }
        
        updateAgents(deltaTime);
        
        // Auto-stop when all agents are dead (but only after a grace period to avoid immediate stop)
        const timeSinceStart = timestamp - playStartTime;
        const gracePeriod = 500; // ms - give sequence time to actually run
        if (!isPaused && agents.length === 0 && timeSinceStart > gracePeriod) {
          isPlaying = false;
          isPaused = false;
          activeNotes.length = 0;
          
          // Stop all sounds
          midi.stopAll();
          audioSynth.stopAll();
          
          // Reset beat counter
          document.getElementById('beat-value').textContent = '1:1:1';
          
          // Update graph counter one final time
          const totalLinks = Array.from(notes.values()).reduce((sum, note) => sum + note.links.length, 0);
          document.getElementById('graph-value').textContent = `${notes.size}:${totalLinks}:0`;
          
          // Update button states
          document.getElementById('play-btn').disabled = false;
          document.getElementById('pause-btn').disabled = true;
          document.getElementById('stop-btn').disabled = true;
          
          console.log('Auto-stopped: all agents dead');
        }
        
        render();
      }
      
      requestAnimationFrame(updateLoop);
    }
    
    // Mouse wheel for zoom
    // Wheel zoom disabled - use Alt+left drag instead
    /*
    canvas.addEventListener('wheel', (e) => {
      e.preventDefault();
      
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      
      // Zoom towards mouse position
      const worldBefore = screenToWorld(mouseX, mouseY);
      
      const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
      zoom *= zoomFactor;
      
      // Clamp zoom
      zoom = Math.max(0.1, Math.min(zoom, 5));
      
      const worldAfter = screenToWorld(mouseX, mouseY);
      
      // Adjust pan to keep mouse over same world point
      panX += (worldAfter.x - worldBefore.x) * zoom;
      panY += (worldAfter.y - worldBefore.y) * zoom;
      
      render();
    });
    */
    
    canvas.addEventListener('mousedown', (e) => {
      const world = getWorldPosition(e);
      
      if (e.button === 0 && e.shiftKey) {
        // Shift+left drag - pan universe
        e.preventDefault();
        isPanning = true;
        lastMouseX = e.clientX;
        lastMouseY = e.clientY;
        canvas.style.cursor = 'move'; // NSEW compass cursor
      }
      else if (e.button === 0 && e.altKey) {
        // Alt+left drag - zoom
        e.preventDefault();
        zooming = true;
        zoomStartY = e.clientY;
        zoomStartX = e.clientX;
        zoomStartValue = zoom;
        canvas.style.cursor = 'zoom-in'; // Magnifying glass
      }
      else if (e.button === 0 && e.ctrlKey) {
        // Ctrl+left drag on note - create link
        e.preventDefault();
        const note = findNoteAt(world.x, world.y);
        if (note) {
          linkingFromNote = note;
          linkingMousePos = world;
          canvas.style.cursor = 'crosshair';
        }
      }
      else if (e.button === 0) {
        // Left click - check for link first (higher priority), then note
        const linkData = findLinkAt(world.x, world.y);
        if (linkData) {
          selectedLink = linkData;
          selectedNote = null;
          updatePropertiesSidebar();
          render();
        }
        else {
          const note = findNoteAt(world.x, world.y);
          if (note) {
            selectedNote = note;
            selectedLink = null;
            sortNoteLinks(note); // Sort links for predictable arrow key navigation
            updatePropertiesSidebar();
            
            // Also allow dragging
            draggedNote = note;
            dragStartWorld = { x: world.x, y: world.y };
            draggedNoteOriginalPos = { x: note.x, y: note.y };
            canvas.style.cursor = 'grabbing';
          }
        }
        // Click on empty space - no-op (keep current selection)
      }
    });
    
    canvas.addEventListener('dblclick', (e) => {
      const world = getWorldPosition(e);
      const snapped = snapToGrid(world.x, world.y);
      const key = posKey(snapped.x, snapped.y);
      
      if (!notes.has(key)) {
        // Create new note
        const note = createNote(snapped.x, snapped.y);
        // Auto-set as start note if this is the first note
        if (notes.size === 0) {
          note.isStart = true;
        }
        notes.set(key, note);
        
        // Auto-select the newly created note
        selectedNote = note;
        selectedLink = null;
        sortNoteLinks(note); // Sort links for predictable arrow key navigation
        updatePropertiesSidebar();
        
        render();
      } else {
        // Toggle root status on existing note
        const note = notes.get(key);
        note.isStart = !note.isStart;
        render();
      }
    });
    
    window.addEventListener('mousemove', (e) => {
      if (isPanning) {
        const dx = e.clientX - lastMouseX;
        const dy = e.clientY - lastMouseY;
        
        panX += dx;
        panY += dy;
        
        lastMouseX = e.clientX;
        lastMouseY = e.clientY;
        
        render();
      }
      else if (zooming) {
        const deltaY = zoomStartY - e.clientY; // Up = zoom in, only use vertical
        const zoomDelta = deltaY * 0.005; // Sensitivity
        
        let newZoom = zoomStartValue + zoomDelta;
        newZoom = Math.max(0.1, Math.min(5, newZoom));
        
        // Zoom towards original mouse position (stored at start)
        const rect = canvas.getBoundingClientRect();
        const mouseX = zoomStartX - rect.left;
        const mouseY = zoomStartY - rect.top;
        
        const worldBefore = screenToWorld(mouseX, mouseY);
        zoom = newZoom;
        const worldAfter = screenToWorld(mouseX, mouseY);
        
        panX += (worldAfter.x - worldBefore.x) * zoom;
        panY += (worldAfter.y - worldBefore.y) * zoom;
        
        render();
      }
      else if (draggedNote) {
        const world = getWorldPosition(e);
        
        const dx = world.x - dragStartWorld.x;
        const dy = world.y - dragStartWorld.y;
        
        draggedNote.x = draggedNoteOriginalPos.x + dx;
        draggedNote.y = draggedNoteOriginalPos.y + dy;
        
        render();
      }
      else if (linkingFromNote) {
        const world = getWorldPosition(e);
        
        linkingMousePos = world;
        render();
      }
    });
    
    window.addEventListener('mouseup', (e) => {
      if (e.button === 0) {
        if (isPanning) {
          isPanning = false;
          canvas.style.cursor = 'default';
        }
        else if (zooming) {
          zooming = false;
          canvas.style.cursor = 'default';
        }
        else if (linkingFromNote) {
          // Complete link creation
          const world = getWorldPosition(e);
          
          let targetNote = findNoteAt(world.x, world.y);
          let createdNewNote = false;
          
          // If no note at drop location, create one
          if (!targetNote && targetNote !== linkingFromNote) {
            const snapped = snapToGrid(world.x, world.y);
            const key = posKey(snapped.x, snapped.y);
            
            if (!notes.has(key)) {
              targetNote = createNote(snapped.x, snapped.y);
              notes.set(key, targetNote);
              createdNewNote = true;
            }
            else {
              targetNote = notes.get(key);
            }
          }
          
          if (targetNote && targetNote !== linkingFromNote) {
            // Add link - copy from template
            const newLink = {
              x: targetNote.x,
              y: targetNote.y,
              weight: lastLinkTemplate.weight,
              probability: lastLinkTemplate.probability,
              group: lastLinkTemplate.group,
              phase: lastLinkTemplate.phase
            };
            linkingFromNote.links.push(newLink);
            
            // Update template from this newly created link
            lastLinkTemplate = { ...newLink };
            
            // If we created a new note, select it; otherwise select the link
            if (createdNewNote) {
              selectedNote = targetNote;
              selectedLink = null;
            } else {
              selectedLink = {
                sourceNote: linkingFromNote,
                link: linkingFromNote.links[linkingFromNote.links.length - 1],
                linkIndex: linkingFromNote.links.length - 1
              };
              selectedNote = null;
            }
            
            updatePropertiesSidebar();
          }
          
          linkingFromNote = null;
          linkingMousePos = null;
          canvas.style.cursor = 'default';
          render();
        }
        else if (draggedNote) {
          // Snap to grid and update map key
          const oldKey = posKey(draggedNoteOriginalPos.x, draggedNoteOriginalPos.y);
          
          const snapped = snapToGrid(draggedNote.x, draggedNote.y);
          const newKey = posKey(snapped.x, snapped.y);
          
          // Update all links that point to this note's old position
          for (const note of notes.values()) {
            for (const link of note.links) {
              if (link.x === draggedNoteOriginalPos.x && link.y === draggedNoteOriginalPos.y) {
                link.x = snapped.x;
                link.y = snapped.y;
              }
            }
          }
          
          // Update the note's position
          draggedNote.x = snapped.x;
          draggedNote.y = snapped.y;
          
          // Update map
          notes.delete(oldKey);
          notes.set(newKey, draggedNote);
          
          draggedNote = null;
          dragStartWorld = null;
          draggedNoteOriginalPos = null;
          canvas.style.cursor = 'default';
          
          render();
        }
        // Left click on empty space - do nothing (safe)
      }
    });
    
    // Initial render
    resizeCanvas();
    
    // Start main update loop
    updateLoop(0);
    
    // Initialize MIDI
    midi.init();
    
    // Resize canvas on window resize
    window.addEventListener('resize', resizeCanvas);
    
    // Click status light to retry connection
    document.getElementById('status-light').addEventListener('click', () => {
      if (!midi.connected) {
        midi.init();
      }
    });
    
    // BPM display
    const bpmDisplay = document.getElementById('bpm-display');
    const bpmValue = document.getElementById('bpm-value');
    let bpmDragging = false;
    let bpmDragStartX = 0;
    let bpmDragStartValue = 0;
    
    bpmDisplay.addEventListener('mousedown', (e) => {
      e.stopPropagation();
      e.preventDefault();
      bpmDragging = true;
      bpmDragStartX = e.clientX;
      bpmDragStartValue = settings.bpm;
      bpmDisplay.style.cursor = 'ew-resize';
    });
    
    window.addEventListener('mousemove', (e) => {
      if (bpmDragging) {
        const deltaX = e.clientX - bpmDragStartX; // Right = increase
        const deltaBPM = Math.round(deltaX); // 1 pixel per BPM
        let newBPM = bpmDragStartValue + deltaBPM;
        
        // Clamp between 40 and 300
        newBPM = Math.max(40, Math.min(300, newBPM));
        
        settings.bpm = newBPM;
        bpmValue.textContent = newBPM;
      }
    });
    
    window.addEventListener('mouseup', (e) => {
      if (bpmDragging) {
        bpmDragging = false;
        bpmDisplay.style.cursor = 'ew-resize';
      }
    });
    
    // Transport controls
    const playBtn = document.getElementById('play-btn');
    const pauseBtn = document.getElementById('pause-btn');
    const stopBtn = document.getElementById('stop-btn');
    
    playBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      isPlaying = true;
      isPaused = false;
      playBtn.disabled = true;
      pauseBtn.disabled = false;
      stopBtn.disabled = false;
      playBtn.classList.remove('active');
      lastFrameTime = 0;
      playStartTime = performance.now(); // Record play start time
      beatCount = 0;
      
      // Small delay before starting (gives user a moment)
      setTimeout(() => {
        if (isPlaying) { // Check we haven't stopped already
          triggerRootNotes();
          spawnAgentsFromStartNotes();
        }
      }, settings.playStartDelay);
    });
    
    pauseBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      isPaused = !isPaused;
      pauseBtn.classList.toggle('active', isPaused);
      if (!isPaused) {
        lastFrameTime = 0; // Reset timing when resuming
        // Adjust playStartTime to account for paused duration
        playStartTime = performance.now() - (beatCount * (60000 / settings.bpm));
      }
    });
    
    stopBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      isPlaying = false;
      isPaused = false;
      playBtn.disabled = false;
      pauseBtn.disabled = true;
      stopBtn.disabled = true;
      pauseBtn.classList.remove('active');
      agents.length = 0; // Clear all agents
      beatCount = 0;
      
      // Send note-off for all active notes
      if (midi.useWebAudio) {
        audioSynth.stopAll();
      } else {
        for (const activeNote of activeNotes) {
          midi.sendNoteOff(activeNote.midiNote, activeNote.channel);
        }
      }
      activeNotes.length = 0;
      
      document.getElementById('beat-value').textContent = '1:1:1';
      
      // Update graph counter
      const totalLinks = Array.from(notes.values()).reduce((sum, note) => sum + note.links.length, 0);
      document.getElementById('graph-value').textContent = `${notes.size}:${totalLinks}:${agents.length}`;
      
      render(); // Redraw without agents
    });
    
    // Menu bar dropdown logic
    const menuFile = document.getElementById('menu-file');
    const fileDropdown = document.getElementById('file-dropdown');
    const menuSave = document.getElementById('menu-save');
    const menuLoad = document.getElementById('menu-load');
    
    const menuWebAudio = document.getElementById('menu-webaudio');
    const webAudioDropdown = document.getElementById('webaudio-dropdown');
    
    // Toggle File dropdown on click
    menuFile.addEventListener('click', (e) => {
      e.stopPropagation();
      fileDropdown.classList.toggle('active');
      webAudioDropdown.classList.remove('active');
    });
    
    // Toggle Web Audio dropdown on click
    menuWebAudio.addEventListener('click', (e) => {
      e.stopPropagation();
      webAudioDropdown.classList.toggle('active');
      fileDropdown.classList.remove('active');
    });
    
    // Close dropdowns when clicking elsewhere
    document.addEventListener('click', () => {
      fileDropdown.classList.remove('active');
      webAudioDropdown.classList.remove('active');
    });
    
    // File menu actions
    menuSave.addEventListener('click', (e) => {
      e.stopPropagation();
      fileDropdown.classList.remove('active');
      saveSequence();
    });
    
    menuLoad.addEventListener('click', (e) => {
      e.stopPropagation();
      fileDropdown.classList.remove('active');
      loadSequence();
    });
    
    // Web Audio menu actions - show channel settings
    webAudioDropdown.querySelectorAll('.menu-dropdown-item').forEach(item => {
      item.addEventListener('click', (e) => {
        e.stopPropagation();
        webAudioDropdown.classList.remove('active');
        const channel = parseInt(item.dataset.channel);
        showChannelSettings(channel);
      });
    });
    
    // Keyboard navigation: Arrow keys to cycle through notes OR links (depending on current selection)
    window.addEventListener('keydown', (e) => {
      // Don't handle keyboard shortcuts if typing in text fields
      const activeElement = document.activeElement;
      const isTyping = activeElement && (
        activeElement.tagName === 'INPUT' || 
        activeElement.tagName === 'TEXTAREA'
      );
      
      if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
        // Allow arrow keys in text fields
        if (isTyping) return;
        
        e.preventDefault();
        
        // Determine which type to cycle through based on current selection
        const cycleNotes = selectedNote !== null || selectedLink === null;
        
        // Build list of selectable items of the same type
        const selectables = [];
        
        if (cycleNotes) {
          // Cycle through notes only
          for (const note of notes.values()) {
            selectables.push({ type: 'note', data: note });
          }
        } else {
          // Cycle through links only
          for (const note of notes.values()) {
            for (let i = 0; i < note.links.length; i++) {
              selectables.push({ 
                type: 'link', 
                data: { sourceNote: note, link: note.links[i], linkIndex: i }
              });
            }
          }
        }
        
        if (selectables.length === 0) return;
        
        // Find current selection index
        let currentIndex = -1;
        if (selectedNote) {
          currentIndex = selectables.findIndex(s => s.type === 'note' && s.data === selectedNote);
        } else if (selectedLink) {
          currentIndex = selectables.findIndex(s => 
            s.type === 'link' && 
            s.data.sourceNote === selectedLink.sourceNote && 
            s.data.linkIndex === selectedLink.linkIndex
          );
        }
        
        // Calculate next index
        let nextIndex;
        if (e.key === 'ArrowLeft') {
          // ArrowLeft: go backward
          nextIndex = currentIndex <= 0 ? selectables.length - 1 : currentIndex - 1;
        } else {
          // ArrowRight: go forward
          nextIndex = currentIndex >= selectables.length - 1 ? 0 : currentIndex + 1;
        }
        
        // Select next item
        const next = selectables[nextIndex];
        if (next.type === 'note') {
          selectedNote = next.data;
          selectedLink = null;
          sortNoteLinks(selectedNote); // Sort links for predictable arrow key navigation
        } else {
          selectedLink = next.data;
          selectedNote = null;
        }
        
        updatePropertiesSidebar();
        render();
      }
      
      // Tab key: toggle between note and its links
      if (e.key === 'Tab') {
        // Allow Tab in text fields for navigation
        if (isTyping) return;
        
        e.preventDefault();
        
        if (selectedNote) {
          // Switch from note to first link from that note
          if (selectedNote.links.length > 0) {
            selectedLink = {
              sourceNote: selectedNote,
              link: selectedNote.links[0],
              linkIndex: 0
            };
            selectedNote = null;
            updatePropertiesSidebar();
            render();
          }
        } else if (selectedLink) {
          // Switch from link to its source note
          selectedNote = selectedLink.sourceNote;
          selectedLink = null;
          sortNoteLinks(selectedNote); // Sort links for predictable arrow key navigation
          updatePropertiesSidebar();
          render();
        }
      }
      
      // Escape key: deselect and show default properties
      if (e.key === 'Escape') {
        // Allow Escape in text fields (though it doesn't do anything by default)
        if (isTyping) return;
        
        selectedNote = null;
        selectedLink = null;
        updatePropertiesSidebar();
        render();
      }
      
      // Delete key: delete selected note or link
      if (e.key === 'Delete' || e.key === 'Backspace') {
        // Allow Delete/Backspace in text fields for editing
        if (isTyping) return;
        
        if (selectedNote) {
          // Delete selected note
          const key = posKey(selectedNote.x, selectedNote.y);
          
          // Remove all links pointing TO this note from other notes
          for (const otherNote of notes.values()) {
            otherNote.links = otherNote.links.filter(link => 
              !(link.x === selectedNote.x && link.y === selectedNote.y)
            );
          }
          
          // Delete the note itself
          notes.delete(key);
          selectedNote = null;
          updatePropertiesSidebar();
          render();
        } else if (selectedLink) {
          // Delete selected link
          selectedLink.sourceNote.links.splice(selectedLink.linkIndex, 1);
          selectedLink = null;
          updatePropertiesSidebar();
          render();
        }
      }
    });
    
    // Prevent transport button events from reaching canvas
    [playBtn, pauseBtn, stopBtn].forEach(btn => {
      btn.addEventListener('mousedown', (e) => e.stopPropagation());
      btn.addEventListener('mouseup', (e) => e.stopPropagation());
    });
         
    // Initialize properties sidebar with helpful hints
    updatePropertiesSidebar();
    render();
  </script>
</body>
</html>